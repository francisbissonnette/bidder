"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/services/scraper.ts":
/*!*********************************!*\
  !*** ./src/services/scraper.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scraper: function() { return /* binding */ scraper; }\n/* harmony export */ });\nclass ScraperService {\n    initializeScrapers() {\n        // Helper function to remove Chinese characters\n        const removeChineseCharacters = (text)=>{\n            // Remove Chinese characters (Unicode range for Chinese characters)\n            return text.replace(/[\\u4e00-\\u9fff\\u3400-\\u4dbf\\uf900-\\ufaff\\uf900-\\ufaff\\u3300-\\u33ff\\ufe30-\\ufe4f\\uf900-\\ufaff\\uff00-\\uffef]/g, \"\")// Remove multiple spaces\n            .replace(/\\s+/g, \" \")// Trim spaces\n            .trim();\n        };\n        // Card Hobby Scraper\n        this.scrapers.set(\"cardhobby\", {\n            name: \"Card Hobby\",\n            urlPattern: /cardhobby\\.com\\/#\\/carddetails\\/\\d+/,\n            rateLimit: {\n                maxRequests: 10,\n                timeWindow: 1000 * 60 // 1 minute\n            },\n            validateData: (data)=>{\n                var _data_data, _data_data1, _data_data2;\n                console.log(\"\\uD83D\\uDD0D [Scraper] Validating Card Hobby data:\", data);\n                const isValid = (data === null || data === void 0 ? void 0 : (_data_data = data.data) === null || _data_data === void 0 ? void 0 : _data_data.TitImg) != null && typeof (data === null || data === void 0 ? void 0 : (_data_data1 = data.data) === null || _data_data1 === void 0 ? void 0 : _data_data1.USD_Price) === \"string\" && typeof (data === null || data === void 0 ? void 0 : (_data_data2 = data.data) === null || _data_data2 === void 0 ? void 0 : _data_data2.Title) === \"string\";\n                console.log(\"✅ [Scraper] Validation result:\", isValid);\n                return isValid;\n            },\n            extractData: async (url, data)=>{\n                var _data_data, _data_data1, _data_data2, _data_data3, _data_data4;\n                console.log(\"\\uD83D\\uDD0D [Scraper] Extracting Card Hobby data:\", data);\n                console.log(\"\\uD83D\\uDD0D [Scraper] Full API response structure:\", JSON.stringify(data, null, 2));\n                console.log(\"\\uD83D\\uDD0D [Scraper] Data object keys:\", Object.keys(data.data || {}));\n                const imageUrl = ((_data_data = data.data) === null || _data_data === void 0 ? void 0 : _data_data.TitImg) || \"\";\n                const currentBid = parseFloat((_data_data1 = data.data) === null || _data_data1 === void 0 ? void 0 : _data_data1.USD_HighestPrice) || 0;\n                const rawTitle = ((_data_data2 = data.data) === null || _data_data2 === void 0 ? void 0 : _data_data2.Title) || \"Unknown Item\";\n                console.log(\"\\uD83D\\uDCDD [Scraper] Raw title:\", rawTitle);\n                const name = removeChineseCharacters(rawTitle);\n                console.log(\"\\uD83D\\uDCDD [Scraper] Cleaned title:\", name);\n                const sellerUrl = ((_data_data3 = data.data) === null || _data_data3 === void 0 ? void 0 : _data_data3.SellRealName) ? \"https://www.cardhobby.com/#/shop/\".concat(data.data.SellRealName) : window.location.origin;\n                // Get the date from EffectiveTime\n                let formattedDate = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString().slice(0, 16);\n                if ((_data_data4 = data.data) === null || _data_data4 === void 0 ? void 0 : _data_data4.EffectiveTime) {\n                    console.log(\"\\uD83D\\uDCC5 [Scraper] Raw EffectiveTime:\", data.data.EffectiveTime);\n                    // Parse the date string (format: \"2025/6/5 20:23:30\")\n                    const [datePart, timePart] = data.data.EffectiveTime.split(\" \");\n                    const [year, month, day] = datePart.split(\"/\");\n                    const [hours, minutes] = timePart.split(\":\");\n                    // Subtract 12 hours\n                    let adjustedHours = parseInt(hours) - 12;\n                    if (adjustedHours < 0) {\n                        adjustedHours += 24;\n                    }\n                    // Format as YYYY-MM-DDThh:mm\n                    formattedDate = \"\".concat(year, \"-\").concat(month.padStart(2, \"0\"), \"-\").concat(day.padStart(2, \"0\"), \"T\").concat(String(adjustedHours).padStart(2, \"0\"), \":\").concat(minutes);\n                    console.log(\"\\uD83D\\uDCC5 [Scraper] Formatted date (12h subtracted):\", formattedDate);\n                } else {\n                    console.log(\"⚠️ [Scraper] No EffectiveTime found in response\");\n                }\n                const result = {\n                    name,\n                    url,\n                    imageUrl,\n                    sellerUrl,\n                    bid: 0,\n                    currentBid,\n                    market: 0,\n                    date: formattedDate\n                };\n                console.log(\"✅ [Scraper] Extracted data:\", result);\n                return result;\n            }\n        });\n    // Add more scrapers here as needed\n    }\n    static getInstance() {\n        if (!ScraperService.instance) {\n            ScraperService.instance = new ScraperService();\n        }\n        return ScraperService.instance;\n    }\n    async waitForRateLimit(scraperName) {\n        const scraper = this.scrapers.get(scraperName);\n        if (!(scraper === null || scraper === void 0 ? void 0 : scraper.rateLimit)) return;\n        const now = Date.now();\n        const requests = this.requestCounts.get(scraperName) || [];\n        // Remove old requests outside the time window\n        const validRequests = requests.filter((time)=>now - time < scraper.rateLimit.timeWindow);\n        if (validRequests.length >= scraper.rateLimit.maxRequests) {\n            const oldestRequest = validRequests[0];\n            const waitTime = oldestRequest + scraper.rateLimit.timeWindow - now;\n            console.log(\"Rate limit reached for \".concat(scraperName, \", waiting \").concat(waitTime, \"ms\"));\n            await new Promise((resolve)=>setTimeout(resolve, waitTime));\n        }\n        // Update request count\n        this.requestCounts.set(scraperName, [\n            ...validRequests,\n            now\n        ]);\n    }\n    async fetchWithRetry(url, options) {\n        let timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5000;\n        let lastError = null;\n        for(let attempt = 0; attempt < this.MAX_RETRIES; attempt++){\n            try {\n                console.log(\"Fetch attempt \".concat(attempt + 1, \" for \").concat(url));\n                const controller = new AbortController();\n                const id = setTimeout(()=>controller.abort(), timeout);\n                const response = await fetch(url, {\n                    ...options,\n                    signal: controller.signal\n                });\n                clearTimeout(id);\n                console.log(\"Fetch successful for \".concat(url, \", status: \").concat(response.status));\n                return response;\n            } catch (error) {\n                lastError = error;\n                console.error(\"Fetch attempt \".concat(attempt + 1, \" failed:\"), error);\n                if (attempt < this.MAX_RETRIES - 1) {\n                    const delay = this.RETRY_DELAY * Math.pow(2, attempt);\n                    console.log(\"Waiting \".concat(delay, \"ms before retry\"));\n                    await new Promise((resolve)=>setTimeout(resolve, delay));\n                }\n            }\n        }\n        throw lastError || new Error(\"Failed to fetch after retries\");\n    }\n    async handleCardHobbyScrape(url) {\n        var _url_match;\n        console.log(\"\\uD83D\\uDD0D [Scraper] Starting Card Hobby scrape for URL:\", url);\n        // Extract card ID from URL like https://www.cardhobby.com/#/carddetails/67180979\n        const cardId = (_url_match = url.match(/carddetails\\/(\\d+)/)) === null || _url_match === void 0 ? void 0 : _url_match[1];\n        if (!cardId) {\n            console.error(\"❌ [Scraper] Invalid URL format - could not extract card ID\");\n            throw new Error(\"Invalid URL format\");\n        }\n        console.log(\"✅ [Scraper] Extracted card ID:\", cardId);\n        await this.waitForRateLimit(\"cardhobby\");\n        // Get the specific card details using the direct API endpoint\n        const apiUrl = \"https://gatewayapi.cardhobby.com/card/Commodity/DetailCommodity/?memberid=499559&token=b9e22c0e118ce211f9611a818cc5c0b0&operator_id=499559&CommodityID=\".concat(cardId, \"&buyerSource=CA&lag=en&device=Web&version=1&appname=Card+Hobby\");\n        console.log(\"\\uD83C\\uDF10 [Scraper] Fetching card details from:\", apiUrl);\n        try {\n            console.log(\"\\uD83D\\uDCE1 [Scraper] Sending API request...\");\n            const response = await this.fetchWithRetry(apiUrl, {\n                method: \"GET\",\n                headers: {\n                    \"Accept\": \"*/*\",\n                    \"Content-Type\": \"application/json\",\n                    \"Origin\": \"http://localhost:3000\",\n                    \"Referer\": \"http://localhost:3000/\",\n                    \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:139.0) Gecko/20100101 Firefox/139.0\",\n                    \"Accept-Language\": \"en-CA,en-US;q=0.7,en;q=0.3\",\n                    \"Accept-Encoding\": \"gzip, deflate, br, zstd\",\n                    \"Connection\": \"keep-alive\",\n                    \"Sec-Fetch-Dest\": \"empty\",\n                    \"Sec-Fetch-Mode\": \"cors\",\n                    \"Sec-Fetch-Site\": \"cross-site\"\n                },\n                mode: \"cors\",\n                credentials: \"omit\"\n            });\n            if (!response.ok) {\n                console.error(\"❌ [Scraper] API request failed with status:\", response.status);\n                if (response.status === 404) {\n                    throw new Error(\"Card not found. Please verify the card ID is correct.\");\n                }\n                throw new Error(\"API request failed: \".concat(response.status));\n            }\n            console.log(\"✅ [Scraper] API request successful, parsing response...\");\n            const data = await response.json();\n            console.log(\"\\uD83D\\uDCE6 [Scraper] Raw API response:\", data);\n            // Check if the response contains valid data\n            if (!(data === null || data === void 0 ? void 0 : data.data)) {\n                console.error(\"❌ [Scraper] Invalid response format - missing data field\");\n                throw new Error(\"Invalid response format from API\");\n            }\n            console.log(\"✅ [Scraper] Successfully parsed API response\");\n            return data;\n        } catch (error) {\n            console.error(\"❌ [Scraper] Error fetching card details:\", error);\n            throw error;\n        }\n    }\n    isCacheValid(entry) {\n        return Date.now() - entry.timestamp < this.CACHE_DURATION;\n    }\n    async scrapeItem(url) {\n        console.log(\"Starting scrape for URL:\", url);\n        try {\n            // Check cache first\n            const cachedEntry = this.cache.get(url);\n            if (cachedEntry && this.isCacheValid(cachedEntry)) {\n                console.log(\"Returning cached data for:\", url);\n                return cachedEntry.data;\n            }\n            // Find the appropriate scraper for the URL\n            const scraper = Array.from(this.scrapers.values()).find((s)=>s.urlPattern.test(url));\n            if (!scraper) {\n                console.error(\"No scraper found for URL:\", url);\n                throw new Error(\"No scraper available for this URL\");\n            }\n            console.log(\"Found scraper:\", scraper.name);\n            let data;\n            if (scraper.name === \"Card Hobby\") {\n                data = await this.handleCardHobbyScrape(url);\n            } else {\n                console.error(\"Unsupported website:\", url);\n                throw new Error(\"Unsupported website\");\n            }\n            // Validate the data\n            if (!scraper.validateData(data)) {\n                console.error(\"Invalid data received:\", data);\n                throw new Error(\"Invalid data received from scraper\");\n            }\n            // Extract data using the scraper's extractData function\n            const extractedData = await scraper.extractData(url, data);\n            // Cache the result\n            this.cache.set(url, {\n                data: extractedData,\n                timestamp: Date.now()\n            });\n            console.log(\"Successfully scraped and cached data for:\", url);\n            return extractedData;\n        } catch (error) {\n            console.error(\"Error scraping item:\", error);\n            if (error instanceof Error) {\n                throw new Error(\"Failed to scrape item details: \".concat(error.message));\n            }\n            throw new Error(\"Failed to scrape item details\");\n        }\n    }\n    // Method to clear cache for a specific URL or all URLs\n    clearCache(url) {\n        if (url) {\n            this.cache.delete(url);\n            console.log(\"Cleared cache for URL:\", url);\n        } else {\n            this.cache.clear();\n            console.log(\"Cleared all cache\");\n        }\n    }\n    constructor(){\n        this.scrapers = new Map();\n        this.cache = new Map();\n        this.requestCounts = new Map();\n        this.CACHE_DURATION = 1000 * 60 * 5 // 5 minutes\n        ;\n        this.MAX_RETRIES = 3;\n        this.RETRY_DELAY = 1000 // 1 second\n        ;\n        this.initializeScrapers();\n    }\n}\nconst scraper = ScraperService.getInstance();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9zY3JhcGVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFrQkEsTUFBTUE7SUFhSUMscUJBQXFCO1FBQzNCLCtDQUErQztRQUMvQyxNQUFNQywwQkFBMEIsQ0FBQ0M7WUFDL0IsbUVBQW1FO1lBQ25FLE9BQU9BLEtBQUtDLE9BQU8sQ0FBQywrR0FBK0csR0FDakkseUJBQXlCO2FBQ3hCQSxPQUFPLENBQUMsUUFBUSxJQUNqQixjQUFjO2FBQ2JDLElBQUk7UUFDVDtRQUVBLHFCQUFxQjtRQUNyQixJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDLGFBQWE7WUFDN0JDLE1BQU07WUFDTkMsWUFBWTtZQUNaQyxXQUFXO2dCQUNUQyxhQUFhO2dCQUNiQyxZQUFZLE9BQU8sR0FBRyxXQUFXO1lBQ25DO1lBQ0FDLGNBQWMsQ0FBQ0M7b0JBRUdBLFlBQ0ZBLGFBQ0FBO2dCQUhkQyxRQUFRQyxHQUFHLENBQUMsc0RBQTRDRjtnQkFDeEQsTUFBTUcsVUFBVUgsQ0FBQUEsaUJBQUFBLDRCQUFBQSxhQUFBQSxLQUFNQSxJQUFJLGNBQVZBLGlDQUFBQSxXQUFZSSxNQUFNLEtBQUksUUFDL0IsUUFBT0osaUJBQUFBLDRCQUFBQSxjQUFBQSxLQUFNQSxJQUFJLGNBQVZBLGtDQUFBQSxZQUFZSyxTQUFTLE1BQUssWUFDakMsUUFBT0wsaUJBQUFBLDRCQUFBQSxjQUFBQSxLQUFNQSxJQUFJLGNBQVZBLGtDQUFBQSxZQUFZTSxLQUFLLE1BQUs7Z0JBQ3BDTCxRQUFRQyxHQUFHLENBQUMsa0NBQWtDQztnQkFDOUMsT0FBT0E7WUFDVDtZQUNBSSxhQUFhLE9BQU9DLEtBQWFSO29CQUtkQSxZQUNhQSxhQUNiQSxhQU1DQSxhQUlkQTtnQkFoQkpDLFFBQVFDLEdBQUcsQ0FBQyxzREFBNENGO2dCQUN4REMsUUFBUUMsR0FBRyxDQUFDLHVEQUE2Q08sS0FBS0MsU0FBUyxDQUFDVixNQUFNLE1BQU07Z0JBQ3BGQyxRQUFRQyxHQUFH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QixNQUFNLElBQUlBLE1BQU0sa0NBQWdELE9BQWRMLE1BQU04QixPQUFPO1lBQ2pFO1lBQ0EsTUFBTSxJQUFJekIsTUFBTTtRQUNsQjtJQUNGO0lBRUEsdURBQXVEO0lBQ3ZEMEIsV0FBV3BHLEdBQVksRUFBUTtRQUM3QixJQUFJQSxLQUFLO1lBQ1AsSUFBSSxDQUFDMkYsS0FBSyxDQUFDVSxNQUFNLENBQUNyRztZQUNsQlAsUUFBUUMsR0FBRyxDQUFDLDBCQUEwQk07UUFDeEMsT0FBTztZQUNMLElBQUksQ0FBQzJGLEtBQUssQ0FBQ1csS0FBSztZQUNoQjdHLFFBQVFDLEdBQUcsQ0FBQztRQUNkO0lBQ0Y7SUFuUkEsYUFBc0I7YUFQZFYsV0FBdUMsSUFBSXVIO2FBQzNDWixRQUFpQyxJQUFJWTthQUNyQzNELGdCQUF1QyxJQUFJMkQ7YUFDbENmLGlCQUFpQixPQUFPLEtBQUssRUFBRyxZQUFZOzthQUM1QzdCLGNBQWM7YUFDZFksY0FBYyxLQUFNLFdBQVc7O1FBRzlDLElBQUksQ0FBQzVGLGtCQUFrQjtJQUN6QjtBQWtSRjtBQUVPLE1BQU04RCxVQUFVL0QsZUFBZTJELFdBQVcsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvc2NyYXBlci50cz8zYzAyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEl0ZW0gfSBmcm9tICdAL3R5cGVzL2l0ZW0nO1xuXG5pbnRlcmZhY2UgU2NyYXBlckNvbmZpZyB7XG4gIG5hbWU6IHN0cmluZztcbiAgdXJsUGF0dGVybjogUmVnRXhwO1xuICBleHRyYWN0RGF0YTogKHVybDogc3RyaW5nLCBkYXRhOiBhbnkpID0+IFByb21pc2U8T21pdDxJdGVtLCAnaWQnPj47XG4gIHZhbGlkYXRlRGF0YTogKGRhdGE6IGFueSkgPT4gYm9vbGVhbjtcbiAgcmF0ZUxpbWl0Pzoge1xuICAgIG1heFJlcXVlc3RzOiBudW1iZXI7XG4gICAgdGltZVdpbmRvdzogbnVtYmVyOyAvLyBpbiBtaWxsaXNlY29uZHNcbiAgfTtcbn1cblxuaW50ZXJmYWNlIENhY2hlRW50cnkge1xuICBkYXRhOiBPbWl0PEl0ZW0sICdpZCc+O1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbn1cblxuY2xhc3MgU2NyYXBlclNlcnZpY2Uge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogU2NyYXBlclNlcnZpY2U7XG4gIHByaXZhdGUgc2NyYXBlcnM6IE1hcDxzdHJpbmcsIFNjcmFwZXJDb25maWc+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIGNhY2hlOiBNYXA8c3RyaW5nLCBDYWNoZUVudHJ5PiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSByZXF1ZXN0Q291bnRzOiBNYXA8c3RyaW5nLCBudW1iZXJbXT4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgQ0FDSEVfRFVSQVRJT04gPSAxMDAwICogNjAgKiA1OyAvLyA1IG1pbnV0ZXNcbiAgcHJpdmF0ZSByZWFkb25seSBNQVhfUkVUUklFUyA9IDM7XG4gIHByaXZhdGUgcmVhZG9ubHkgUkVUUllfREVMQVkgPSAxMDAwOyAvLyAxIHNlY29uZFxuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pbml0aWFsaXplU2NyYXBlcnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZVNjcmFwZXJzKCkge1xuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byByZW1vdmUgQ2hpbmVzZSBjaGFyYWN0ZXJzXG4gICAgY29uc3QgcmVtb3ZlQ2hpbmVzZUNoYXJhY3RlcnMgPSAodGV4dDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICAgIC8vIFJlbW92ZSBDaGluZXNlIGNoYXJhY3RlcnMgKFVuaWNvZGUgcmFuZ2UgZm9yIENoaW5lc2UgY2hhcmFjdGVycylcbiAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1tcXHU0ZTAwLVxcdTlmZmZcXHUzNDAwLVxcdTRkYmZcXHVmOTAwLVxcdWZhZmZcXHVmOTAwLVxcdWZhZmZcXHUzMzAwLVxcdTMzZmZcXHVmZTMwLVxcdWZlNGZcXHVmOTAwLVxcdWZhZmZcXHVmZjAwLVxcdWZmZWZdL2csICcnKVxuICAgICAgICAvLyBSZW1vdmUgbXVsdGlwbGUgc3BhY2VzXG4gICAgICAgIC5yZXBsYWNlKC9cXHMrL2csICcgJylcbiAgICAgICAgLy8gVHJpbSBzcGFjZXNcbiAgICAgICAgLnRyaW0oKTtcbiAgICB9O1xuXG4gICAgLy8gQ2FyZCBIb2JieSBTY3JhcGVyXG4gICAgdGhpcy5zY3JhcGVycy5zZXQoJ2NhcmRob2JieScsIHtcbiAgICAgIG5hbWU6ICdDYXJkIEhvYmJ5JyxcbiAgICAgIHVybFBhdHRlcm46IC9jYXJkaG9iYnlcXC5jb21cXC8jXFwvY2FyZGRldGFpbHNcXC9cXGQrLyxcbiAgICAgIHJhdGVMaW1pdDoge1xuICAgICAgICBtYXhSZXF1ZXN0czogMTAsXG4gICAgICAgIHRpbWVXaW5kb3c6IDEwMDAgKiA2MCAvLyAxIG1pbnV0ZVxuICAgICAgfSxcbiAgICAgIHZhbGlkYXRlRGF0YTogKGRhdGE6IGFueSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBbU2NyYXBlcl0gVmFsaWRhdGluZyBDYXJkIEhvYmJ5IGRhdGE6JywgZGF0YSk7XG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSBkYXRhPy5kYXRhPy5UaXRJbWcgIT0gbnVsbCAmJiBcbiAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhPy5kYXRhPy5VU0RfUHJpY2UgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICB0eXBlb2YgZGF0YT8uZGF0YT8uVGl0bGUgPT09ICdzdHJpbmcnO1xuICAgICAgICBjb25zb2xlLmxvZygn4pyFIFtTY3JhcGVyXSBWYWxpZGF0aW9uIHJlc3VsdDonLCBpc1ZhbGlkKTtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgICB9LFxuICAgICAgZXh0cmFjdERhdGE6IGFzeW5jICh1cmw6IHN0cmluZywgZGF0YTogYW55KSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFtTY3JhcGVyXSBFeHRyYWN0aW5nIENhcmQgSG9iYnkgZGF0YTonLCBkYXRhKTtcbiAgICAgICAgY29uc29sZS5sb2coJ/CflI0gW1NjcmFwZXJdIEZ1bGwgQVBJIHJlc3BvbnNlIHN0cnVjdHVyZTonLCBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFtTY3JhcGVyXSBEYXRhIG9iamVjdCBrZXlzOicsIE9iamVjdC5rZXlzKGRhdGEuZGF0YSB8fCB7fSkpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaW1hZ2VVcmwgPSBkYXRhLmRhdGE/LlRpdEltZyB8fCAnJztcbiAgICAgICAgY29uc3QgY3VycmVudEJpZCA9IHBhcnNlRmxvYXQoZGF0YS5kYXRhPy5VU0RfSGlnaGVzdFByaWNlKSB8fCAwO1xuICAgICAgICBjb25zdCByYXdUaXRsZSA9IGRhdGEuZGF0YT8uVGl0bGUgfHwgJ1Vua25vd24gSXRlbSc7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OdIFtTY3JhcGVyXSBSYXcgdGl0bGU6JywgcmF3VGl0bGUpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbmFtZSA9IHJlbW92ZUNoaW5lc2VDaGFyYWN0ZXJzKHJhd1RpdGxlKTtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk50gW1NjcmFwZXJdIENsZWFuZWQgdGl0bGU6JywgbmFtZSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBzZWxsZXJVcmwgPSBkYXRhLmRhdGE/LlNlbGxSZWFsTmFtZSA/IGBodHRwczovL3d3dy5jYXJkaG9iYnkuY29tLyMvc2hvcC8ke2RhdGEuZGF0YS5TZWxsUmVhbE5hbWV9YCA6IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG5cbiAgICAgICAgLy8gR2V0IHRoZSBkYXRlIGZyb20gRWZmZWN0aXZlVGltZVxuICAgICAgICBsZXQgZm9ybWF0dGVkRGF0ZSA9IG5ldyBEYXRlKERhdGUubm93KCkgKyAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDE2KTtcbiAgICAgICAgaWYgKGRhdGEuZGF0YT8uRWZmZWN0aXZlVGltZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OFIFtTY3JhcGVyXSBSYXcgRWZmZWN0aXZlVGltZTonLCBkYXRhLmRhdGEuRWZmZWN0aXZlVGltZSk7XG4gICAgICAgICAgLy8gUGFyc2UgdGhlIGRhdGUgc3RyaW5nIChmb3JtYXQ6IFwiMjAyNS82LzUgMjA6MjM6MzBcIilcbiAgICAgICAgICBjb25zdCBbZGF0ZVBhcnQsIHRpbWVQYXJ0XSA9IGRhdGEuZGF0YS5FZmZlY3RpdmVUaW1lLnNwbGl0KCcgJyk7XG4gICAgICAgICAgY29uc3QgW3llYXIsIG1vbnRoLCBkYXldID0gZGF0ZVBhcnQuc3BsaXQoJy8nKTtcbiAgICAgICAgICBjb25zdCBbaG91cnMsIG1pbnV0ZXNdID0gdGltZVBhcnQuc3BsaXQoJzonKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTdWJ0cmFjdCAxMiBob3Vyc1xuICAgICAgICAgIGxldCBhZGp1c3RlZEhvdXJzID0gcGFyc2VJbnQoaG91cnMpIC0gMTI7XG4gICAgICAgICAgaWYgKGFkanVzdGVkSG91cnMgPCAwKSB7XG4gICAgICAgICAgICBhZGp1c3RlZEhvdXJzICs9IDI0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGb3JtYXQgYXMgWVlZWS1NTS1ERFRoaDptbVxuICAgICAgICAgIGZvcm1hdHRlZERhdGUgPSBgJHt5ZWFyfS0ke21vbnRoLnBhZFN0YXJ0KDIsICcwJyl9LSR7ZGF5LnBhZFN0YXJ0KDIsICcwJyl9VCR7U3RyaW5nKGFkanVzdGVkSG91cnMpLnBhZFN0YXJ0KDIsICcwJyl9OiR7bWludXRlc31gO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OFIFtTY3JhcGVyXSBGb3JtYXR0ZWQgZGF0ZSAoMTJoIHN1YnRyYWN0ZWQpOicsIGZvcm1hdHRlZERhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gW1NjcmFwZXJdIE5vIEVmZmVjdGl2ZVRpbWUgZm91bmQgaW4gcmVzcG9uc2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICBpbWFnZVVybCxcbiAgICAgICAgICBzZWxsZXJVcmwsXG4gICAgICAgICAgYmlkOiAwLFxuICAgICAgICAgIGN1cnJlbnRCaWQsXG4gICAgICAgICAgbWFya2V0OiAwLFxuICAgICAgICAgIGRhdGU6IGZvcm1hdHRlZERhdGUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgW1NjcmFwZXJdIEV4dHJhY3RlZCBkYXRhOicsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgbW9yZSBzY3JhcGVycyBoZXJlIGFzIG5lZWRlZFxuICB9XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IFNjcmFwZXJTZXJ2aWNlIHtcbiAgICBpZiAoIVNjcmFwZXJTZXJ2aWNlLmluc3RhbmNlKSB7XG4gICAgICBTY3JhcGVyU2VydmljZS5pbnN0YW5jZSA9IG5ldyBTY3JhcGVyU2VydmljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gU2NyYXBlclNlcnZpY2UuaW5zdGFuY2U7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHdhaXRGb3JSYXRlTGltaXQoc2NyYXBlck5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHNjcmFwZXIgPSB0aGlzLnNjcmFwZXJzLmdldChzY3JhcGVyTmFtZSk7XG4gICAgaWYgKCFzY3JhcGVyPy5yYXRlTGltaXQpIHJldHVybjtcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgcmVxdWVzdHMgPSB0aGlzLnJlcXVlc3RDb3VudHMuZ2V0KHNjcmFwZXJOYW1lKSB8fCBbXTtcbiAgICBcbiAgICAvLyBSZW1vdmUgb2xkIHJlcXVlc3RzIG91dHNpZGUgdGhlIHRpbWUgd2luZG93XG4gICAgY29uc3QgdmFsaWRSZXF1ZXN0cyA9IHJlcXVlc3RzLmZpbHRlcih0aW1lID0+IG5vdyAtIHRpbWUgPCBzY3JhcGVyLnJhdGVMaW1pdCEudGltZVdpbmRvdyk7XG4gICAgXG4gICAgaWYgKHZhbGlkUmVxdWVzdHMubGVuZ3RoID49IHNjcmFwZXIucmF0ZUxpbWl0IS5tYXhSZXF1ZXN0cykge1xuICAgICAgY29uc3Qgb2xkZXN0UmVxdWVzdCA9IHZhbGlkUmVxdWVzdHNbMF07XG4gICAgICBjb25zdCB3YWl0VGltZSA9IG9sZGVzdFJlcXVlc3QgKyBzY3JhcGVyLnJhdGVMaW1pdCEudGltZVdpbmRvdyAtIG5vdztcbiAgICAgIGNvbnNvbGUubG9nKGBSYXRlIGxpbWl0IHJlYWNoZWQgZm9yICR7c2NyYXBlck5hbWV9LCB3YWl0aW5nICR7d2FpdFRpbWV9bXNgKTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCB3YWl0VGltZSkpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSByZXF1ZXN0IGNvdW50XG4gICAgdGhpcy5yZXF1ZXN0Q291bnRzLnNldChzY3JhcGVyTmFtZSwgWy4uLnZhbGlkUmVxdWVzdHMsIG5vd10pO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmZXRjaFdpdGhSZXRyeSh1cmw6IHN0cmluZywgb3B0aW9uczogUmVxdWVzdEluaXQsIHRpbWVvdXQgPSA1MDAwKTogUHJvbWlzZTxSZXNwb25zZT4ge1xuICAgIGxldCBsYXN0RXJyb3I6IEVycm9yIHwgbnVsbCA9IG51bGw7XG4gICAgXG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCB0aGlzLk1BWF9SRVRSSUVTOyBhdHRlbXB0KyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBGZXRjaCBhdHRlbXB0ICR7YXR0ZW1wdCArIDF9IGZvciAke3VybH1gKTtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgY29uc3QgaWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dCk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICBjb25zb2xlLmxvZyhgRmV0Y2ggc3VjY2Vzc2Z1bCBmb3IgJHt1cmx9LCBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsYXN0RXJyb3IgPSBlcnJvciBhcyBFcnJvcjtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmV0Y2ggYXR0ZW1wdCAke2F0dGVtcHQgKyAxfSBmYWlsZWQ6YCwgZXJyb3IpO1xuICAgICAgICBpZiAoYXR0ZW1wdCA8IHRoaXMuTUFYX1JFVFJJRVMgLSAxKSB7XG4gICAgICAgICAgY29uc3QgZGVsYXkgPSB0aGlzLlJFVFJZX0RFTEFZICogTWF0aC5wb3coMiwgYXR0ZW1wdCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYFdhaXRpbmcgJHtkZWxheX1tcyBiZWZvcmUgcmV0cnlgKTtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IGxhc3RFcnJvciB8fCBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBhZnRlciByZXRyaWVzJyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZUNhcmRIb2JieVNjcmFwZSh1cmw6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc29sZS5sb2coJ/CflI0gW1NjcmFwZXJdIFN0YXJ0aW5nIENhcmQgSG9iYnkgc2NyYXBlIGZvciBVUkw6JywgdXJsKTtcbiAgICAvLyBFeHRyYWN0IGNhcmQgSUQgZnJvbSBVUkwgbGlrZSBodHRwczovL3d3dy5jYXJkaG9iYnkuY29tLyMvY2FyZGRldGFpbHMvNjcxODA5NzlcbiAgICBjb25zdCBjYXJkSWQgPSB1cmwubWF0Y2goL2NhcmRkZXRhaWxzXFwvKFxcZCspLyk/LlsxXTtcbiAgICBpZiAoIWNhcmRJZCkge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIFtTY3JhcGVyXSBJbnZhbGlkIFVSTCBmb3JtYXQgLSBjb3VsZCBub3QgZXh0cmFjdCBjYXJkIElEJyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVVJMIGZvcm1hdCcpO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZygn4pyFIFtTY3JhcGVyXSBFeHRyYWN0ZWQgY2FyZCBJRDonLCBjYXJkSWQpO1xuXG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yUmF0ZUxpbWl0KCdjYXJkaG9iYnknKTtcblxuICAgIC8vIEdldCB0aGUgc3BlY2lmaWMgY2FyZCBkZXRhaWxzIHVzaW5nIHRoZSBkaXJlY3QgQVBJIGVuZHBvaW50XG4gICAgY29uc3QgYXBpVXJsID0gYGh0dHBzOi8vZ2F0ZXdheWFwaS5jYXJkaG9iYnkuY29tL2NhcmQvQ29tbW9kaXR5L0RldGFpbENvbW1vZGl0eS8/bWVtYmVyaWQ9NDk5NTU5JnRva2VuPWI5ZTIyYzBlMTE4Y2UyMTFmOTYxMWE4MThjYzVjMGIwJm9wZXJhdG9yX2lkPTQ5OTU1OSZDb21tb2RpdHlJRD0ke2NhcmRJZH0mYnV5ZXJTb3VyY2U9Q0EmbGFnPWVuJmRldmljZT1XZWImdmVyc2lvbj0xJmFwcG5hbWU9Q2FyZCtIb2JieWA7XG4gICAgY29uc29sZS5sb2coJ/CfjJAgW1NjcmFwZXJdIEZldGNoaW5nIGNhcmQgZGV0YWlscyBmcm9tOicsIGFwaVVybCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OhIFtTY3JhcGVyXSBTZW5kaW5nIEFQSSByZXF1ZXN0Li4uJyk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hXaXRoUmV0cnkoYXBpVXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQWNjZXB0JzogJyovKicsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnT3JpZ2luJzogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCcsXG4gICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cDovL2xvY2FsaG9zdDozMDAwLycsXG4gICAgICAgICAgJ1VzZXItQWdlbnQnOiAnTW96aWxsYS81LjAgKE1hY2ludG9zaDsgSW50ZWwgTWFjIE9TIFggMTAuMTU7IHJ2OjEzOS4wKSBHZWNrby8yMDEwMDEwMSBGaXJlZm94LzEzOS4wJyxcbiAgICAgICAgICAnQWNjZXB0LUxhbmd1YWdlJzogJ2VuLUNBLGVuLVVTO3E9MC43LGVuO3E9MC4zJyxcbiAgICAgICAgICAnQWNjZXB0LUVuY29kaW5nJzogJ2d6aXAsIGRlZmxhdGUsIGJyLCB6c3RkJyxcbiAgICAgICAgICAnQ29ubmVjdGlvbic6ICdrZWVwLWFsaXZlJyxcbiAgICAgICAgICAnU2VjLUZldGNoLURlc3QnOiAnZW1wdHknLFxuICAgICAgICAgICdTZWMtRmV0Y2gtTW9kZSc6ICdjb3JzJyxcbiAgICAgICAgICAnU2VjLUZldGNoLVNpdGUnOiAnY3Jvc3Mtc2l0ZSdcbiAgICAgICAgfSxcbiAgICAgICAgbW9kZTogJ2NvcnMnLFxuICAgICAgICBjcmVkZW50aWFsczogJ29taXQnXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgW1NjcmFwZXJdIEFQSSByZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhcmQgbm90IGZvdW5kLiBQbGVhc2UgdmVyaWZ5IHRoZSBjYXJkIElEIGlzIGNvcnJlY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgcmVxdWVzdCBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFtTY3JhcGVyXSBBUEkgcmVxdWVzdCBzdWNjZXNzZnVsLCBwYXJzaW5nIHJlc3BvbnNlLi4uJyk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc29sZS5sb2coJ/Cfk6YgW1NjcmFwZXJdIFJhdyBBUEkgcmVzcG9uc2U6JywgZGF0YSk7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSByZXNwb25zZSBjb250YWlucyB2YWxpZCBkYXRhXG4gICAgICBpZiAoIWRhdGE/LmRhdGEpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIFtTY3JhcGVyXSBJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdCAtIG1pc3NpbmcgZGF0YSBmaWVsZCcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVzcG9uc2UgZm9ybWF0IGZyb20gQVBJJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgW1NjcmFwZXJdIFN1Y2Nlc3NmdWxseSBwYXJzZWQgQVBJIHJlc3BvbnNlJyk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIFtTY3JhcGVyXSBFcnJvciBmZXRjaGluZyBjYXJkIGRldGFpbHM6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpc0NhY2hlVmFsaWQoZW50cnk6IENhY2hlRW50cnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGVudHJ5LnRpbWVzdGFtcCA8IHRoaXMuQ0FDSEVfRFVSQVRJT047XG4gIH1cblxuICBhc3luYyBzY3JhcGVJdGVtKHVybDogc3RyaW5nKTogUHJvbWlzZTxPbWl0PEl0ZW0sICdpZCc+PiB7XG4gICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIHNjcmFwZSBmb3IgVVJMOicsIHVybCk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGNhY2hlIGZpcnN0XG4gICAgICBjb25zdCBjYWNoZWRFbnRyeSA9IHRoaXMuY2FjaGUuZ2V0KHVybCk7XG4gICAgICBpZiAoY2FjaGVkRW50cnkgJiYgdGhpcy5pc0NhY2hlVmFsaWQoY2FjaGVkRW50cnkpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdSZXR1cm5pbmcgY2FjaGVkIGRhdGEgZm9yOicsIHVybCk7XG4gICAgICAgIHJldHVybiBjYWNoZWRFbnRyeS5kYXRhO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIHRoZSBhcHByb3ByaWF0ZSBzY3JhcGVyIGZvciB0aGUgVVJMXG4gICAgICBjb25zdCBzY3JhcGVyID0gQXJyYXkuZnJvbSh0aGlzLnNjcmFwZXJzLnZhbHVlcygpKS5maW5kKHMgPT4gcy51cmxQYXR0ZXJuLnRlc3QodXJsKSk7XG4gICAgICBcbiAgICAgIGlmICghc2NyYXBlcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdObyBzY3JhcGVyIGZvdW5kIGZvciBVUkw6JywgdXJsKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzY3JhcGVyIGF2YWlsYWJsZSBmb3IgdGhpcyBVUkwnKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIHNjcmFwZXI6Jywgc2NyYXBlci5uYW1lKTtcblxuICAgICAgbGV0IGRhdGE7XG4gICAgICBpZiAoc2NyYXBlci5uYW1lID09PSAnQ2FyZCBIb2JieScpIHtcbiAgICAgICAgZGF0YSA9IGF3YWl0IHRoaXMuaGFuZGxlQ2FyZEhvYmJ5U2NyYXBlKHVybCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdVbnN1cHBvcnRlZCB3ZWJzaXRlOicsIHVybCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgd2Vic2l0ZScpO1xuICAgICAgfVxuXG4gICAgICAvLyBWYWxpZGF0ZSB0aGUgZGF0YVxuICAgICAgaWYgKCFzY3JhcGVyLnZhbGlkYXRlRGF0YShkYXRhKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGRhdGEgcmVjZWl2ZWQ6JywgZGF0YSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIHJlY2VpdmVkIGZyb20gc2NyYXBlcicpO1xuICAgICAgfVxuXG4gICAgICAvLyBFeHRyYWN0IGRhdGEgdXNpbmcgdGhlIHNjcmFwZXIncyBleHRyYWN0RGF0YSBmdW5jdGlvblxuICAgICAgY29uc3QgZXh0cmFjdGVkRGF0YSA9IGF3YWl0IHNjcmFwZXIuZXh0cmFjdERhdGEodXJsLCBkYXRhKTtcblxuICAgICAgLy8gQ2FjaGUgdGhlIHJlc3VsdFxuICAgICAgdGhpcy5jYWNoZS5zZXQodXJsLCB7XG4gICAgICAgIGRhdGE6IGV4dHJhY3RlZERhdGEsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgc2NyYXBlZCBhbmQgY2FjaGVkIGRhdGEgZm9yOicsIHVybCk7XG4gICAgICByZXR1cm4gZXh0cmFjdGVkRGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2NyYXBpbmcgaXRlbTonLCBlcnJvcik7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzY3JhcGUgaXRlbSBkZXRhaWxzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzY3JhcGUgaXRlbSBkZXRhaWxzJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gTWV0aG9kIHRvIGNsZWFyIGNhY2hlIGZvciBhIHNwZWNpZmljIFVSTCBvciBhbGwgVVJMc1xuICBjbGVhckNhY2hlKHVybD86IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh1cmwpIHtcbiAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKHVybCk7XG4gICAgICBjb25zb2xlLmxvZygnQ2xlYXJlZCBjYWNoZSBmb3IgVVJMOicsIHVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2FjaGUuY2xlYXIoKTtcbiAgICAgIGNvbnNvbGUubG9nKCdDbGVhcmVkIGFsbCBjYWNoZScpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2NyYXBlciA9IFNjcmFwZXJTZXJ2aWNlLmdldEluc3RhbmNlKCk7ICJdLCJuYW1lcyI6WyJTY3JhcGVyU2VydmljZSIsImluaXRpYWxpemVTY3JhcGVycyIsInJlbW92ZUNoaW5lc2VDaGFyYWN0ZXJzIiwidGV4dCIsInJlcGxhY2UiLCJ0cmltIiwic2NyYXBlcnMiLCJzZXQiLCJuYW1lIiwidXJsUGF0dGVybiIsInJhdGVMaW1pdCIsIm1heFJlcXVlc3RzIiwidGltZVdpbmRvdyIsInZhbGlkYXRlRGF0YSIsImRhdGEiLCJjb25zb2xlIiwibG9nIiwiaXNWYWxpZCIsIlRpdEltZyIsIlVTRF9QcmljZSIsIlRpdGxlIiwiZXh0cmFjdERhdGEiLCJ1cmwiLCJKU09OIiwic3RyaW5naWZ5IiwiT2JqZWN0Iiwia2V5cyIsImltYWdlVXJsIiwiY3VycmVudEJpZCIsInBhcnNlRmxvYXQiLCJVU0RfSGlnaGVzdFByaWNlIiwicmF3VGl0bGUiLCJzZWxsZXJVcmwiLCJTZWxsUmVhbE5hbWUiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsImZvcm1hdHRlZERhdGUiLCJEYXRlIiwibm93IiwidG9JU09TdHJpbmciLCJzbGljZSIsIkVmZmVjdGl2ZVRpbWUiLCJkYXRlUGFydCIsInRpbWVQYXJ0Iiwic3BsaXQiLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJob3VycyIsIm1pbnV0ZXMiLCJhZGp1c3RlZEhvdXJzIiwicGFyc2VJbnQiLCJwYWRTdGFydCIsIlN0cmluZyIsInJlc3VsdCIsImJpZCIsIm1hcmtldCIsImRhdGUiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwid2FpdEZvclJhdGVMaW1pdCIsInNjcmFwZXJOYW1lIiwic2NyYXBlciIsImdldCIsInJlcXVlc3RzIiwicmVxdWVzdENvdW50cyIsInZhbGlkUmVxdWVzdHMiLCJmaWx0ZXIiLCJ0aW1lIiwibGVuZ3RoIiwib2xkZXN0UmVxdWVzdCIsIndhaXRUaW1lIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZmV0Y2hXaXRoUmV0cnkiLCJvcHRpb25zIiwidGltZW91dCIsImxhc3RFcnJvciIsImF0dGVtcHQiLCJNQVhfUkVUUklFUyIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJpZCIsImFib3J0IiwicmVzcG9uc2UiLCJmZXRjaCIsInNpZ25hbCIsImNsZWFyVGltZW91dCIsInN0YXR1cyIsImVycm9yIiwiZGVsYXkiLCJSRVRSWV9ERUxBWSIsIk1hdGgiLCJwb3ciLCJFcnJvciIsImhhbmRsZUNhcmRIb2JieVNjcmFwZSIsImNhcmRJZCIsIm1hdGNoIiwiYXBpVXJsIiwibWV0aG9kIiwiaGVhZGVycyIsIm1vZGUiLCJjcmVkZW50aWFscyIsIm9rIiwianNvbiIsImlzQ2FjaGVWYWxpZCIsImVudHJ5IiwidGltZXN0YW1wIiwiQ0FDSEVfRFVSQVRJT04iLCJzY3JhcGVJdGVtIiwiY2FjaGVkRW50cnkiLCJjYWNoZSIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsImZpbmQiLCJzIiwidGVzdCIsImV4dHJhY3RlZERhdGEiLCJtZXNzYWdlIiwiY2xlYXJDYWNoZSIsImRlbGV0ZSIsImNsZWFyIiwiTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/scraper.ts\n"));

/***/ })

});