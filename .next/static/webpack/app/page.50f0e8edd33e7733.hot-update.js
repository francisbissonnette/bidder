"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/services/scraper.ts":
/*!*********************************!*\
  !*** ./src/services/scraper.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scraperService: function() { return /* binding */ scraperService; }\n/* harmony export */ });\nclass ScraperService {\n    initializeScrapers() {\n        // Card Hobby Scraper\n        this.scrapers.set(\"cardhobby\", {\n            name: \"Card Hobby\",\n            urlPattern: /cardhobby\\.com\\/#\\/carddetails\\/\\d+/,\n            rateLimit: {\n                maxRequests: 10,\n                timeWindow: 1000 * 60 // 1 minute\n            },\n            validateData: (data)=>{\n                var _data_data, _data_data1, _data_data2;\n                console.log(\"Validating Card Hobby data:\", data);\n                const isValid = (data === null || data === void 0 ? void 0 : (_data_data = data.data) === null || _data_data === void 0 ? void 0 : _data_data.imageUrl) != null && typeof (data === null || data === void 0 ? void 0 : (_data_data1 = data.data) === null || _data_data1 === void 0 ? void 0 : _data_data1.price) === \"number\" && typeof (data === null || data === void 0 ? void 0 : (_data_data2 = data.data) === null || _data_data2 === void 0 ? void 0 : _data_data2.title) === \"string\";\n                console.log(\"Validation result:\", isValid);\n                return isValid;\n            },\n            extractData: async (url, data)=>{\n                var _data_data, _data_data1, _data_data2, _data_data3;\n                console.log(\"Extracting Card Hobby data:\", data);\n                const imageUrl = ((_data_data = data.data) === null || _data_data === void 0 ? void 0 : _data_data.imageUrl) || \"\";\n                const currentBid = ((_data_data1 = data.data) === null || _data_data1 === void 0 ? void 0 : _data_data1.price) || 0;\n                const name = ((_data_data2 = data.data) === null || _data_data2 === void 0 ? void 0 : _data_data2.title) || \"Unknown Item\";\n                const sellerUrl = ((_data_data3 = data.data) === null || _data_data3 === void 0 ? void 0 : _data_data3.sellerUrl) || window.location.origin;\n                const result = {\n                    name,\n                    url,\n                    imageUrl,\n                    sellerUrl,\n                    bid: 0,\n                    currentBid,\n                    market: 0,\n                    date: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()\n                };\n                console.log(\"Extracted data:\", result);\n                return result;\n            }\n        });\n    // Add more scrapers here as needed\n    }\n    static getInstance() {\n        if (!ScraperService.instance) {\n            ScraperService.instance = new ScraperService();\n        }\n        return ScraperService.instance;\n    }\n    async waitForRateLimit(scraperName) {\n        const scraper = this.scrapers.get(scraperName);\n        if (!(scraper === null || scraper === void 0 ? void 0 : scraper.rateLimit)) return;\n        const now = Date.now();\n        const requests = this.requestCounts.get(scraperName) || [];\n        // Remove old requests outside the time window\n        const validRequests = requests.filter((time)=>now - time < scraper.rateLimit.timeWindow);\n        if (validRequests.length >= scraper.rateLimit.maxRequests) {\n            const oldestRequest = validRequests[0];\n            const waitTime = oldestRequest + scraper.rateLimit.timeWindow - now;\n            console.log(\"Rate limit reached for \".concat(scraperName, \", waiting \").concat(waitTime, \"ms\"));\n            await new Promise((resolve)=>setTimeout(resolve, waitTime));\n        }\n        // Update request count\n        this.requestCounts.set(scraperName, [\n            ...validRequests,\n            now\n        ]);\n    }\n    async fetchWithRetry(url, options) {\n        let timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5000;\n        let lastError = null;\n        for(let attempt = 0; attempt < this.MAX_RETRIES; attempt++){\n            try {\n                console.log(\"Fetch attempt \".concat(attempt + 1, \" for \").concat(url));\n                const controller = new AbortController();\n                const id = setTimeout(()=>controller.abort(), timeout);\n                const response = await fetch(url, {\n                    ...options,\n                    signal: controller.signal\n                });\n                clearTimeout(id);\n                console.log(\"Fetch successful for \".concat(url, \", status: \").concat(response.status));\n                return response;\n            } catch (error) {\n                lastError = error;\n                console.error(\"Fetch attempt \".concat(attempt + 1, \" failed:\"), error);\n                if (attempt < this.MAX_RETRIES - 1) {\n                    const delay = this.RETRY_DELAY * Math.pow(2, attempt);\n                    console.log(\"Waiting \".concat(delay, \"ms before retry\"));\n                    await new Promise((resolve)=>setTimeout(resolve, delay));\n                }\n            }\n        }\n        throw lastError || new Error(\"Failed to fetch after retries\");\n    }\n    async handleCardHobbyScrape(url) {\n        var _url_match;\n        console.log(\"Starting Card Hobby scrape for URL:\", url);\n        // Extract card ID from URL like https://www.cardhobby.com/#/carddetails/67180979\n        const cardId = (_url_match = url.match(/carddetails\\/(\\d+)/)) === null || _url_match === void 0 ? void 0 : _url_match[1];\n        if (!cardId) {\n            throw new Error(\"Invalid URL format\");\n        }\n        console.log(\"Extracted card ID:\", cardId);\n        await this.waitForRateLimit(\"cardhobby\");\n        // Get the specific card details using the direct API endpoint\n        const apiUrl = \"https://www.cardhobby.com/api/card/commodity/detail?cardId=\".concat(cardId, \"&lag=en&device=Web&version=1&appname=Card+Hobby\");\n        console.log(\"Fetching card details from:\", apiUrl);\n        try {\n            const response = await this.fetchWithRetry(apiUrl, {\n                method: \"GET\",\n                headers: {\n                    \"Accept\": \"application/json\",\n                    \"Content-Type\": \"application/json\",\n                    \"Origin\": \"https://www.cardhobby.com\",\n                    \"Referer\": \"https://www.cardhobby.com/\",\n                    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\",\n                    \"sec-ch-ua\": '\"Google Chrome\";v=\"91\", \"Chromium\";v=\"91\"',\n                    \"sec-ch-ua-mobile\": \"?0\",\n                    \"Sec-Fetch-Dest\": \"empty\",\n                    \"Sec-Fetch-Mode\": \"cors\",\n                    \"Sec-Fetch-Site\": \"same-origin\"\n                },\n                mode: \"cors\",\n                credentials: \"include\"\n            });\n            if (!response.ok) {\n                if (response.status === 404) {\n                    throw new Error(\"Card not found. Please verify the card ID is correct.\");\n                }\n                throw new Error(\"API request failed: \".concat(response.status));\n            }\n            const data = await response.json();\n            console.log(\"Card details response:\", data);\n            // Check if the response contains valid data\n            if (!(data === null || data === void 0 ? void 0 : data.data)) {\n                throw new Error(\"Invalid response format from API\");\n            }\n            return data;\n        } catch (error) {\n            console.error(\"Error fetching card details:\", error);\n            // Fallback to alternative API endpoint\n            const fallbackUrl = \"https://gatewayapi.cardhobby.com/card/NewMyCommodity/GetCardDetail?cardId=\".concat(cardId, \"&lag=en&device=Web&version=1&appname=Card+Hobby\");\n            console.log(\"Trying fallback API endpoint:\", fallbackUrl);\n            const fallbackResponse = await this.fetchWithRetry(fallbackUrl, {\n                method: \"GET\",\n                headers: {\n                    \"Accept\": \"application/json\",\n                    \"Content-Type\": \"application/json\",\n                    \"Origin\": \"https://www.cardhobby.com\",\n                    \"Referer\": \"https://www.cardhobby.com/\",\n                    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\"\n                }\n            });\n            if (!fallbackResponse.ok) {\n                throw new Error(\"Fallback API request failed: \".concat(fallbackResponse.status));\n            }\n            const fallbackData = await fallbackResponse.json();\n            console.log(\"Fallback API response:\", fallbackData);\n            if (!(fallbackData === null || fallbackData === void 0 ? void 0 : fallbackData.data)) {\n                throw new Error(\"Invalid response format from fallback API\");\n            }\n            return fallbackData;\n        }\n    }\n    isCacheValid(entry) {\n        return Date.now() - entry.timestamp < this.CACHE_DURATION;\n    }\n    async scrapeItem(url) {\n        console.log(\"Starting scrape for URL:\", url);\n        try {\n            // Check cache first\n            const cachedEntry = this.cache.get(url);\n            if (cachedEntry && this.isCacheValid(cachedEntry)) {\n                console.log(\"Returning cached data for:\", url);\n                return cachedEntry.data;\n            }\n            // Find the appropriate scraper for the URL\n            const scraper = Array.from(this.scrapers.values()).find((s)=>s.urlPattern.test(url));\n            if (!scraper) {\n                console.error(\"No scraper found for URL:\", url);\n                throw new Error(\"No scraper available for this URL\");\n            }\n            console.log(\"Found scraper:\", scraper.name);\n            let data;\n            if (scraper.name === \"Card Hobby\") {\n                data = await this.handleCardHobbyScrape(url);\n            } else {\n                console.error(\"Unsupported website:\", url);\n                throw new Error(\"Unsupported website\");\n            }\n            // Validate the data\n            if (!scraper.validateData(data)) {\n                console.error(\"Invalid data received:\", data);\n                throw new Error(\"Invalid data received from scraper\");\n            }\n            // Extract data using the scraper's extractData function\n            const extractedData = await scraper.extractData(url, data);\n            // Cache the result\n            this.cache.set(url, {\n                data: extractedData,\n                timestamp: Date.now()\n            });\n            console.log(\"Successfully scraped and cached data for:\", url);\n            return extractedData;\n        } catch (error) {\n            console.error(\"Error scraping item:\", error);\n            if (error instanceof Error) {\n                throw new Error(\"Failed to scrape item details: \".concat(error.message));\n            }\n            throw new Error(\"Failed to scrape item details\");\n        }\n    }\n    // Method to clear cache for a specific URL or all URLs\n    clearCache(url) {\n        if (url) {\n            this.cache.delete(url);\n            console.log(\"Cleared cache for URL:\", url);\n        } else {\n            this.cache.clear();\n            console.log(\"Cleared all cache\");\n        }\n    }\n    constructor(){\n        this.scrapers = new Map();\n        this.cache = new Map();\n        this.requestCounts = new Map();\n        this.CACHE_DURATION = 1000 * 60 * 5 // 5 minutes\n        ;\n        this.MAX_RETRIES = 3;\n        this.RETRY_DELAY = 1000 // 1 second\n        ;\n        this.initializeScrapers();\n    }\n}\nconst scraperService = ScraperService.getInstance();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9zY3JhcGVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFrQkEsTUFBTUE7SUFhSUMscUJBQXFCO1FBQzNCLHFCQUFxQjtRQUNyQixJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDLGFBQWE7WUFDN0JDLE1BQU07WUFDTkMsWUFBWTtZQUNaQyxXQUFXO2dCQUNUQyxhQUFhO2dCQUNiQyxZQUFZLE9BQU8sR0FBRyxXQUFXO1lBQ25DO1lBQ0FDLGNBQWMsQ0FBQ0M7b0JBRUdBLFlBQ0ZBLGFBQ0FBO2dCQUhkQyxRQUFRQyxHQUFHLENBQUMsK0JBQStCRjtnQkFDM0MsTUFBTUcsVUFBVUgsQ0FBQUEsaUJBQUFBLDRCQUFBQSxhQUFBQSxLQUFNQSxJQUFJLGNBQVZBLGlDQUFBQSxXQUFZSSxRQUFRLEtBQUksUUFDakMsUUFBT0osaUJBQUFBLDRCQUFBQSxjQUFBQSxLQUFNQSxJQUFJLGNBQVZBLGtDQUFBQSxZQUFZSyxLQUFLLE1BQUssWUFDN0IsUUFBT0wsaUJBQUFBLDRCQUFBQSxjQUFBQSxLQUFNQSxJQUFJLGNBQVZBLGtDQUFBQSxZQUFZTSxLQUFLLE1BQUs7Z0JBQ3BDTCxRQUFRQyxHQUFHLENBQUMsc0JBQXNCQztnQkFDbEMsT0FBT0E7WUFDVDtZQUNBSSxhQUFhLE9BQU9DLEtBQWFSO29CQUVkQSxZQUNFQSxhQUNOQSxhQUNLQTtnQkFKbEJDLFFBQVFDLEdBQUcsQ0FBQywrQkFBK0JGO2dCQUMzQyxNQUFNSSxXQUFXSixFQUFBQSxhQUFBQSxLQUFLQSxJQUFJLGNBQVRBLGlDQUFBQSxXQUFXSSxRQUFRLEtBQUk7Z0JBQ3hDLE1BQU1LLGFBQWFULEVBQUFBLGNBQUFBLEtBQUtBLElBQUksY0FBVEEsa0NBQUFBLFlBQVdLLEtBQUssS0FBSTtnQkFDdkMsTUFBTVgsT0FBT00sRUFBQUEsY0FBQUEsS0FBS0EsSUFBSSxjQUFUQSxrQ0FBQUEsWUFBV00sS0FBSyxLQUFJO2dCQUNqQyxNQUFNSSxZQUFZ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d0JBQXdCQTtZQUN0QyxJQUFJQSxpQkFBaUJLLE9BQU87Z0JBQzFCLE1BQU0sSUFBSUEsTUFBTSxrQ0FBZ0QsT0FBZEwsTUFBTWlDLE9BQU87WUFDakU7WUFDQSxNQUFNLElBQUk1QixNQUFNO1FBQ2xCO0lBQ0Y7SUFFQSx1REFBdUQ7SUFDdkQ2QixXQUFXL0UsR0FBWSxFQUFRO1FBQzdCLElBQUlBLEtBQUs7WUFDUCxJQUFJLENBQUNzRSxLQUFLLENBQUNVLE1BQU0sQ0FBQ2hGO1lBQ2xCUCxRQUFRQyxHQUFHLENBQUMsMEJBQTBCTTtRQUN4QyxPQUFPO1lBQ0wsSUFBSSxDQUFDc0UsS0FBSyxDQUFDVyxLQUFLO1lBQ2hCeEYsUUFBUUMsR0FBRyxDQUFDO1FBQ2Q7SUFDRjtJQTlQQSxhQUFzQjthQVBkVixXQUF1QyxJQUFJa0c7YUFDM0NaLFFBQWlDLElBQUlZO2FBQ3JDOUQsZ0JBQXVDLElBQUk4RDthQUNsQ2YsaUJBQWlCLE9BQU8sS0FBSyxFQUFHLFlBQVk7O2FBQzVDaEMsY0FBYzthQUNkWSxjQUFjLEtBQU0sV0FBVzs7UUFHOUMsSUFBSSxDQUFDaEUsa0JBQWtCO0lBQ3pCO0FBNlBGO0FBRU8sTUFBTW9HLGlCQUFpQnJHLGVBQWUrQixXQUFXLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NlcnZpY2VzL3NjcmFwZXIudHM/M2MwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJdGVtIH0gZnJvbSAnQC90eXBlcy9pdGVtJztcblxuaW50ZXJmYWNlIFNjcmFwZXJDb25maWcge1xuICBuYW1lOiBzdHJpbmc7XG4gIHVybFBhdHRlcm46IFJlZ0V4cDtcbiAgZXh0cmFjdERhdGE6ICh1cmw6IHN0cmluZywgZGF0YTogYW55KSA9PiBQcm9taXNlPE9taXQ8SXRlbSwgJ2lkJz4+O1xuICB2YWxpZGF0ZURhdGE6IChkYXRhOiBhbnkpID0+IGJvb2xlYW47XG4gIHJhdGVMaW1pdD86IHtcbiAgICBtYXhSZXF1ZXN0czogbnVtYmVyO1xuICAgIHRpbWVXaW5kb3c6IG51bWJlcjsgLy8gaW4gbWlsbGlzZWNvbmRzXG4gIH07XG59XG5cbmludGVyZmFjZSBDYWNoZUVudHJ5IHtcbiAgZGF0YTogT21pdDxJdGVtLCAnaWQnPjtcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmNsYXNzIFNjcmFwZXJTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFNjcmFwZXJTZXJ2aWNlO1xuICBwcml2YXRlIHNjcmFwZXJzOiBNYXA8c3RyaW5nLCBTY3JhcGVyQ29uZmlnPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBjYWNoZTogTWFwPHN0cmluZywgQ2FjaGVFbnRyeT4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgcmVxdWVzdENvdW50czogTWFwPHN0cmluZywgbnVtYmVyW10+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHJlYWRvbmx5IENBQ0hFX0RVUkFUSU9OID0gMTAwMCAqIDYwICogNTsgLy8gNSBtaW51dGVzXG4gIHByaXZhdGUgcmVhZG9ubHkgTUFYX1JFVFJJRVMgPSAzO1xuICBwcml2YXRlIHJlYWRvbmx5IFJFVFJZX0RFTEFZID0gMTAwMDsgLy8gMSBzZWNvbmRcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZVNjcmFwZXJzKCk7XG4gIH1cblxuICBwcml2YXRlIGluaXRpYWxpemVTY3JhcGVycygpIHtcbiAgICAvLyBDYXJkIEhvYmJ5IFNjcmFwZXJcbiAgICB0aGlzLnNjcmFwZXJzLnNldCgnY2FyZGhvYmJ5Jywge1xuICAgICAgbmFtZTogJ0NhcmQgSG9iYnknLFxuICAgICAgdXJsUGF0dGVybjogL2NhcmRob2JieVxcLmNvbVxcLyNcXC9jYXJkZGV0YWlsc1xcL1xcZCsvLFxuICAgICAgcmF0ZUxpbWl0OiB7XG4gICAgICAgIG1heFJlcXVlc3RzOiAxMCxcbiAgICAgICAgdGltZVdpbmRvdzogMTAwMCAqIDYwIC8vIDEgbWludXRlXG4gICAgICB9LFxuICAgICAgdmFsaWRhdGVEYXRhOiAoZGF0YTogYW55KSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdWYWxpZGF0aW5nIENhcmQgSG9iYnkgZGF0YTonLCBkYXRhKTtcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IGRhdGE/LmRhdGE/LmltYWdlVXJsICE9IG51bGwgJiYgXG4gICAgICAgICAgICAgICB0eXBlb2YgZGF0YT8uZGF0YT8ucHJpY2UgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICB0eXBlb2YgZGF0YT8uZGF0YT8udGl0bGUgPT09ICdzdHJpbmcnO1xuICAgICAgICBjb25zb2xlLmxvZygnVmFsaWRhdGlvbiByZXN1bHQ6JywgaXNWYWxpZCk7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgICAgfSxcbiAgICAgIGV4dHJhY3REYXRhOiBhc3luYyAodXJsOiBzdHJpbmcsIGRhdGE6IGFueSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnRXh0cmFjdGluZyBDYXJkIEhvYmJ5IGRhdGE6JywgZGF0YSk7XG4gICAgICAgIGNvbnN0IGltYWdlVXJsID0gZGF0YS5kYXRhPy5pbWFnZVVybCB8fCAnJztcbiAgICAgICAgY29uc3QgY3VycmVudEJpZCA9IGRhdGEuZGF0YT8ucHJpY2UgfHwgMDtcbiAgICAgICAgY29uc3QgbmFtZSA9IGRhdGEuZGF0YT8udGl0bGUgfHwgJ1Vua25vd24gSXRlbSc7XG4gICAgICAgIGNvbnN0IHNlbGxlclVybCA9IGRhdGEuZGF0YT8uc2VsbGVyVXJsIHx8IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGltYWdlVXJsLFxuICAgICAgICAgIHNlbGxlclVybCxcbiAgICAgICAgICBiaWQ6IDAsXG4gICAgICAgICAgY3VycmVudEJpZCxcbiAgICAgICAgICBtYXJrZXQ6IDAsXG4gICAgICAgICAgZGF0ZTogbmV3IERhdGUoRGF0ZS5ub3coKSArIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUubG9nKCdFeHRyYWN0ZWQgZGF0YTonLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQWRkIG1vcmUgc2NyYXBlcnMgaGVyZSBhcyBuZWVkZWRcbiAgfVxuXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBTY3JhcGVyU2VydmljZSB7XG4gICAgaWYgKCFTY3JhcGVyU2VydmljZS5pbnN0YW5jZSkge1xuICAgICAgU2NyYXBlclNlcnZpY2UuaW5zdGFuY2UgPSBuZXcgU2NyYXBlclNlcnZpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIFNjcmFwZXJTZXJ2aWNlLmluc3RhbmNlO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB3YWl0Rm9yUmF0ZUxpbWl0KHNjcmFwZXJOYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBzY3JhcGVyID0gdGhpcy5zY3JhcGVycy5nZXQoc2NyYXBlck5hbWUpO1xuICAgIGlmICghc2NyYXBlcj8ucmF0ZUxpbWl0KSByZXR1cm47XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHJlcXVlc3RzID0gdGhpcy5yZXF1ZXN0Q291bnRzLmdldChzY3JhcGVyTmFtZSkgfHwgW107XG4gICAgXG4gICAgLy8gUmVtb3ZlIG9sZCByZXF1ZXN0cyBvdXRzaWRlIHRoZSB0aW1lIHdpbmRvd1xuICAgIGNvbnN0IHZhbGlkUmVxdWVzdHMgPSByZXF1ZXN0cy5maWx0ZXIodGltZSA9PiBub3cgLSB0aW1lIDwgc2NyYXBlci5yYXRlTGltaXQhLnRpbWVXaW5kb3cpO1xuICAgIFxuICAgIGlmICh2YWxpZFJlcXVlc3RzLmxlbmd0aCA+PSBzY3JhcGVyLnJhdGVMaW1pdCEubWF4UmVxdWVzdHMpIHtcbiAgICAgIGNvbnN0IG9sZGVzdFJlcXVlc3QgPSB2YWxpZFJlcXVlc3RzWzBdO1xuICAgICAgY29uc3Qgd2FpdFRpbWUgPSBvbGRlc3RSZXF1ZXN0ICsgc2NyYXBlci5yYXRlTGltaXQhLnRpbWVXaW5kb3cgLSBub3c7XG4gICAgICBjb25zb2xlLmxvZyhgUmF0ZSBsaW1pdCByZWFjaGVkIGZvciAke3NjcmFwZXJOYW1lfSwgd2FpdGluZyAke3dhaXRUaW1lfW1zYCk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgd2FpdFRpbWUpKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgcmVxdWVzdCBjb3VudFxuICAgIHRoaXMucmVxdWVzdENvdW50cy5zZXQoc2NyYXBlck5hbWUsIFsuLi52YWxpZFJlcXVlc3RzLCBub3ddKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hXaXRoUmV0cnkodXJsOiBzdHJpbmcsIG9wdGlvbnM6IFJlcXVlc3RJbml0LCB0aW1lb3V0ID0gNTAwMCk6IFByb21pc2U8UmVzcG9uc2U+IHtcbiAgICBsZXQgbGFzdEVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsO1xuICAgIFxuICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgdGhpcy5NQVhfUkVUUklFUzsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhgRmV0Y2ggYXR0ZW1wdCAke2F0dGVtcHQgKyAxfSBmb3IgJHt1cmx9YCk7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IGlkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXQpO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgY29uc29sZS5sb2coYEZldGNoIHN1Y2Nlc3NmdWwgZm9yICR7dXJsfSwgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbGFzdEVycm9yID0gZXJyb3IgYXMgRXJyb3I7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZldGNoIGF0dGVtcHQgJHthdHRlbXB0ICsgMX0gZmFpbGVkOmAsIGVycm9yKTtcbiAgICAgICAgaWYgKGF0dGVtcHQgPCB0aGlzLk1BWF9SRVRSSUVTIC0gMSkge1xuICAgICAgICAgIGNvbnN0IGRlbGF5ID0gdGhpcy5SRVRSWV9ERUxBWSAqIE1hdGgucG93KDIsIGF0dGVtcHQpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBXYWl0aW5nICR7ZGVsYXl9bXMgYmVmb3JlIHJldHJ5YCk7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBsYXN0RXJyb3IgfHwgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggYWZ0ZXIgcmV0cmllcycpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVDYXJkSG9iYnlTY3JhcGUodXJsOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBDYXJkIEhvYmJ5IHNjcmFwZSBmb3IgVVJMOicsIHVybCk7XG4gICAgLy8gRXh0cmFjdCBjYXJkIElEIGZyb20gVVJMIGxpa2UgaHR0cHM6Ly93d3cuY2FyZGhvYmJ5LmNvbS8jL2NhcmRkZXRhaWxzLzY3MTgwOTc5XG4gICAgY29uc3QgY2FyZElkID0gdXJsLm1hdGNoKC9jYXJkZGV0YWlsc1xcLyhcXGQrKS8pPy5bMV07XG4gICAgaWYgKCFjYXJkSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBVUkwgZm9ybWF0Jyk7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKCdFeHRyYWN0ZWQgY2FyZCBJRDonLCBjYXJkSWQpO1xuXG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yUmF0ZUxpbWl0KCdjYXJkaG9iYnknKTtcblxuICAgIC8vIEdldCB0aGUgc3BlY2lmaWMgY2FyZCBkZXRhaWxzIHVzaW5nIHRoZSBkaXJlY3QgQVBJIGVuZHBvaW50XG4gICAgY29uc3QgYXBpVXJsID0gYGh0dHBzOi8vd3d3LmNhcmRob2JieS5jb20vYXBpL2NhcmQvY29tbW9kaXR5L2RldGFpbD9jYXJkSWQ9JHtjYXJkSWR9JmxhZz1lbiZkZXZpY2U9V2ViJnZlcnNpb249MSZhcHBuYW1lPUNhcmQrSG9iYnlgO1xuICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBjYXJkIGRldGFpbHMgZnJvbTonLCBhcGlVcmwpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hXaXRoUmV0cnkoYXBpVXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ09yaWdpbic6ICdodHRwczovL3d3dy5jYXJkaG9iYnkuY29tJyxcbiAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5jYXJkaG9iYnkuY29tLycsXG4gICAgICAgICAgJ1VzZXItQWdlbnQnOiAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzkxLjAuNDQ3Mi4xMjQgU2FmYXJpLzUzNy4zNicsXG4gICAgICAgICAgJ3NlYy1jaC11YSc6ICdcIkdvb2dsZSBDaHJvbWVcIjt2PVwiOTFcIiwgXCJDaHJvbWl1bVwiO3Y9XCI5MVwiJyxcbiAgICAgICAgICAnc2VjLWNoLXVhLW1vYmlsZSc6ICc/MCcsXG4gICAgICAgICAgJ1NlYy1GZXRjaC1EZXN0JzogJ2VtcHR5JyxcbiAgICAgICAgICAnU2VjLUZldGNoLU1vZGUnOiAnY29ycycsXG4gICAgICAgICAgJ1NlYy1GZXRjaC1TaXRlJzogJ3NhbWUtb3JpZ2luJ1xuICAgICAgICB9LFxuICAgICAgICBtb2RlOiAnY29ycycsXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZSdcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FyZCBub3QgZm91bmQuIFBsZWFzZSB2ZXJpZnkgdGhlIGNhcmQgSUQgaXMgY29ycmVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSByZXF1ZXN0IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZygnQ2FyZCBkZXRhaWxzIHJlc3BvbnNlOicsIGRhdGEpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgcmVzcG9uc2UgY29udGFpbnMgdmFsaWQgZGF0YVxuICAgICAgaWYgKCFkYXRhPy5kYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZSBmb3JtYXQgZnJvbSBBUEknKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGNhcmQgZGV0YWlsczonLCBlcnJvcik7XG4gICAgICAvLyBGYWxsYmFjayB0byBhbHRlcm5hdGl2ZSBBUEkgZW5kcG9pbnRcbiAgICAgIGNvbnN0IGZhbGxiYWNrVXJsID0gYGh0dHBzOi8vZ2F0ZXdheWFwaS5jYXJkaG9iYnkuY29tL2NhcmQvTmV3TXlDb21tb2RpdHkvR2V0Q2FyZERldGFpbD9jYXJkSWQ9JHtjYXJkSWR9JmxhZz1lbiZkZXZpY2U9V2ViJnZlcnNpb249MSZhcHBuYW1lPUNhcmQrSG9iYnlgO1xuICAgICAgY29uc29sZS5sb2coJ1RyeWluZyBmYWxsYmFjayBBUEkgZW5kcG9pbnQ6JywgZmFsbGJhY2tVcmwpO1xuXG4gICAgICBjb25zdCBmYWxsYmFja1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaFdpdGhSZXRyeShmYWxsYmFja1VybCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdPcmlnaW4nOiAnaHR0cHM6Ly93d3cuY2FyZGhvYmJ5LmNvbScsXG4gICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly93d3cuY2FyZGhvYmJ5LmNvbS8nLFxuICAgICAgICAgICdVc2VyLUFnZW50JzogJ01vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS85MS4wLjQ0NzIuMTI0IFNhZmFyaS81MzcuMzYnXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWZhbGxiYWNrUmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWxsYmFjayBBUEkgcmVxdWVzdCBmYWlsZWQ6ICR7ZmFsbGJhY2tSZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZhbGxiYWNrRGF0YSA9IGF3YWl0IGZhbGxiYWNrUmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc29sZS5sb2coJ0ZhbGxiYWNrIEFQSSByZXNwb25zZTonLCBmYWxsYmFja0RhdGEpO1xuXG4gICAgICBpZiAoIWZhbGxiYWNrRGF0YT8uZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVzcG9uc2UgZm9ybWF0IGZyb20gZmFsbGJhY2sgQVBJJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxsYmFja0RhdGE7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpc0NhY2hlVmFsaWQoZW50cnk6IENhY2hlRW50cnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGVudHJ5LnRpbWVzdGFtcCA8IHRoaXMuQ0FDSEVfRFVSQVRJT047XG4gIH1cblxuICBhc3luYyBzY3JhcGVJdGVtKHVybDogc3RyaW5nKTogUHJvbWlzZTxPbWl0PEl0ZW0sICdpZCc+PiB7XG4gICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIHNjcmFwZSBmb3IgVVJMOicsIHVybCk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGNhY2hlIGZpcnN0XG4gICAgICBjb25zdCBjYWNoZWRFbnRyeSA9IHRoaXMuY2FjaGUuZ2V0KHVybCk7XG4gICAgICBpZiAoY2FjaGVkRW50cnkgJiYgdGhpcy5pc0NhY2hlVmFsaWQoY2FjaGVkRW50cnkpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdSZXR1cm5pbmcgY2FjaGVkIGRhdGEgZm9yOicsIHVybCk7XG4gICAgICAgIHJldHVybiBjYWNoZWRFbnRyeS5kYXRhO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIHRoZSBhcHByb3ByaWF0ZSBzY3JhcGVyIGZvciB0aGUgVVJMXG4gICAgICBjb25zdCBzY3JhcGVyID0gQXJyYXkuZnJvbSh0aGlzLnNjcmFwZXJzLnZhbHVlcygpKS5maW5kKHMgPT4gcy51cmxQYXR0ZXJuLnRlc3QodXJsKSk7XG4gICAgICBcbiAgICAgIGlmICghc2NyYXBlcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdObyBzY3JhcGVyIGZvdW5kIGZvciBVUkw6JywgdXJsKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzY3JhcGVyIGF2YWlsYWJsZSBmb3IgdGhpcyBVUkwnKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIHNjcmFwZXI6Jywgc2NyYXBlci5uYW1lKTtcblxuICAgICAgbGV0IGRhdGE7XG4gICAgICBpZiAoc2NyYXBlci5uYW1lID09PSAnQ2FyZCBIb2JieScpIHtcbiAgICAgICAgZGF0YSA9IGF3YWl0IHRoaXMuaGFuZGxlQ2FyZEhvYmJ5U2NyYXBlKHVybCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdVbnN1cHBvcnRlZCB3ZWJzaXRlOicsIHVybCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgd2Vic2l0ZScpO1xuICAgICAgfVxuXG4gICAgICAvLyBWYWxpZGF0ZSB0aGUgZGF0YVxuICAgICAgaWYgKCFzY3JhcGVyLnZhbGlkYXRlRGF0YShkYXRhKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGRhdGEgcmVjZWl2ZWQ6JywgZGF0YSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIHJlY2VpdmVkIGZyb20gc2NyYXBlcicpO1xuICAgICAgfVxuXG4gICAgICAvLyBFeHRyYWN0IGRhdGEgdXNpbmcgdGhlIHNjcmFwZXIncyBleHRyYWN0RGF0YSBmdW5jdGlvblxuICAgICAgY29uc3QgZXh0cmFjdGVkRGF0YSA9IGF3YWl0IHNjcmFwZXIuZXh0cmFjdERhdGEodXJsLCBkYXRhKTtcblxuICAgICAgLy8gQ2FjaGUgdGhlIHJlc3VsdFxuICAgICAgdGhpcy5jYWNoZS5zZXQodXJsLCB7XG4gICAgICAgIGRhdGE6IGV4dHJhY3RlZERhdGEsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgc2NyYXBlZCBhbmQgY2FjaGVkIGRhdGEgZm9yOicsIHVybCk7XG4gICAgICByZXR1cm4gZXh0cmFjdGVkRGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2NyYXBpbmcgaXRlbTonLCBlcnJvcik7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzY3JhcGUgaXRlbSBkZXRhaWxzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzY3JhcGUgaXRlbSBkZXRhaWxzJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gTWV0aG9kIHRvIGNsZWFyIGNhY2hlIGZvciBhIHNwZWNpZmljIFVSTCBvciBhbGwgVVJMc1xuICBjbGVhckNhY2hlKHVybD86IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh1cmwpIHtcbiAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKHVybCk7XG4gICAgICBjb25zb2xlLmxvZygnQ2xlYXJlZCBjYWNoZSBmb3IgVVJMOicsIHVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2FjaGUuY2xlYXIoKTtcbiAgICAgIGNvbnNvbGUubG9nKCdDbGVhcmVkIGFsbCBjYWNoZScpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2NyYXBlclNlcnZpY2UgPSBTY3JhcGVyU2VydmljZS5nZXRJbnN0YW5jZSgpOyAiXSwibmFtZXMiOlsiU2NyYXBlclNlcnZpY2UiLCJpbml0aWFsaXplU2NyYXBlcnMiLCJzY3JhcGVycyIsInNldCIsIm5hbWUiLCJ1cmxQYXR0ZXJuIiwicmF0ZUxpbWl0IiwibWF4UmVxdWVzdHMiLCJ0aW1lV2luZG93IiwidmFsaWRhdGVEYXRhIiwiZGF0YSIsImNvbnNvbGUiLCJsb2ciLCJpc1ZhbGlkIiwiaW1hZ2VVcmwiLCJwcmljZSIsInRpdGxlIiwiZXh0cmFjdERhdGEiLCJ1cmwiLCJjdXJyZW50QmlkIiwic2VsbGVyVXJsIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJyZXN1bHQiLCJiaWQiLCJtYXJrZXQiLCJkYXRlIiwiRGF0ZSIsIm5vdyIsInRvSVNPU3RyaW5nIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsIndhaXRGb3JSYXRlTGltaXQiLCJzY3JhcGVyTmFtZSIsInNjcmFwZXIiLCJnZXQiLCJyZXF1ZXN0cyIsInJlcXVlc3RDb3VudHMiLCJ2YWxpZFJlcXVlc3RzIiwiZmlsdGVyIiwidGltZSIsImxlbmd0aCIsIm9sZGVzdFJlcXVlc3QiLCJ3YWl0VGltZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImZldGNoV2l0aFJldHJ5Iiwib3B0aW9ucyIsInRpbWVvdXQiLCJsYXN0RXJyb3IiLCJhdHRlbXB0IiwiTUFYX1JFVFJJRVMiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwiaWQiLCJhYm9ydCIsInJlc3BvbnNlIiwiZmV0Y2giLCJzaWduYWwiLCJjbGVhclRpbWVvdXQiLCJzdGF0dXMiLCJlcnJvciIsImRlbGF5IiwiUkVUUllfREVMQVkiLCJNYXRoIiwicG93IiwiRXJyb3IiLCJoYW5kbGVDYXJkSG9iYnlTY3JhcGUiLCJjYXJkSWQiLCJtYXRjaCIsImFwaVVybCIsIm1ldGhvZCIsImhlYWRlcnMiLCJtb2RlIiwiY3JlZGVudGlhbHMiLCJvayIsImpzb24iLCJmYWxsYmFja1VybCIsImZhbGxiYWNrUmVzcG9uc2UiLCJmYWxsYmFja0RhdGEiLCJpc0NhY2hlVmFsaWQiLCJlbnRyeSIsInRpbWVzdGFtcCIsIkNBQ0hFX0RVUkFUSU9OIiwic2NyYXBlSXRlbSIsImNhY2hlZEVudHJ5IiwiY2FjaGUiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJmaW5kIiwicyIsInRlc3QiLCJleHRyYWN0ZWREYXRhIiwibWVzc2FnZSIsImNsZWFyQ2FjaGUiLCJkZWxldGUiLCJjbGVhciIsIk1hcCIsInNjcmFwZXJTZXJ2aWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/scraper.ts\n"));

/***/ })

});