"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/services/scraper.ts":
/*!*********************************!*\
  !*** ./src/services/scraper.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scraper: function() { return /* binding */ scraper; }\n/* harmony export */ });\nclass ScraperService {\n    initializeScrapers() {\n        // Helper function to remove Chinese characters\n        const removeChineseCharacters = (text)=>{\n            // Remove Chinese characters (Unicode range for Chinese characters)\n            return text.replace(/[\\u4e00-\\u9fff\\u3400-\\u4dbf\\uf900-\\ufaff\\uf900-\\ufaff\\u3300-\\u33ff\\ufe30-\\ufe4f\\uf900-\\ufaff\\uff00-\\uffef]/g, \"\")// Remove multiple spaces\n            .replace(/\\s+/g, \" \")// Trim spaces\n            .trim();\n        };\n        // Card Hobby Scraper\n        this.scrapers.set(\"cardhobby\", {\n            name: \"Card Hobby\",\n            urlPattern: /cardhobby\\.com\\/#\\/carddetails\\/\\d+/,\n            rateLimit: {\n                maxRequests: 10,\n                timeWindow: 1000 * 60 // 1 minute\n            },\n            validateData: (data)=>{\n                var _data_data, _data_data1, _data_data2;\n                console.log(\"\\uD83D\\uDD0D [Scraper] Validating Card Hobby data:\", data);\n                const isValid = (data === null || data === void 0 ? void 0 : (_data_data = data.data) === null || _data_data === void 0 ? void 0 : _data_data.TitImg) != null && typeof (data === null || data === void 0 ? void 0 : (_data_data1 = data.data) === null || _data_data1 === void 0 ? void 0 : _data_data1.USD_Price) === \"string\" && typeof (data === null || data === void 0 ? void 0 : (_data_data2 = data.data) === null || _data_data2 === void 0 ? void 0 : _data_data2.Title) === \"string\";\n                console.log(\"✅ [Scraper] Validation result:\", isValid);\n                return isValid;\n            },\n            extractData: async (url, data)=>{\n                var _data_data, _data_data1, _data_data2, _data_data3, _data_data4, _data_data5;\n                console.log(\"\\uD83D\\uDD0D [Scraper] Extracting Card Hobby data:\", data);\n                console.log(\"\\uD83D\\uDD0D [Scraper] Full API response structure:\", JSON.stringify(data, null, 2));\n                console.log(\"\\uD83D\\uDD0D [Scraper] Data object keys:\", Object.keys(data.data || {}));\n                const imageUrl = ((_data_data = data.data) === null || _data_data === void 0 ? void 0 : _data_data.TitImg) || \"\";\n                const currentBid = parseFloat((_data_data1 = data.data) === null || _data_data1 === void 0 ? void 0 : _data_data1.USD_Price) || 0;\n                const rawTitle = ((_data_data2 = data.data) === null || _data_data2 === void 0 ? void 0 : _data_data2.Title) || \"Unknown Item\";\n                console.log(\"\\uD83D\\uDCDD [Scraper] Raw title:\", rawTitle);\n                const name = removeChineseCharacters(rawTitle);\n                console.log(\"\\uD83D\\uDCDD [Scraper] Cleaned title:\", name);\n                const sellerUrl = ((_data_data3 = data.data) === null || _data_data3 === void 0 ? void 0 : _data_data3.SellRealName) ? \"https://www.cardhobby.com/#/shop/\".concat(data.data.SellRealName) : window.location.origin;\n                // Parse the effectiveTime and subtract 12 hours\n                let endDate = new Date();\n                console.log(\"\\uD83D\\uDD0D [Scraper] Checking for effectiveTime in data:\", {\n                    hasData: !!data.data,\n                    effectiveTime: (_data_data4 = data.data) === null || _data_data4 === void 0 ? void 0 : _data_data4.effectiveTime\n                });\n                if ((_data_data5 = data.data) === null || _data_data5 === void 0 ? void 0 : _data_data5.effectiveTime) {\n                    console.log(\"\\uD83D\\uDCC5 [Scraper] Raw effectiveTime:\", data.data.effectiveTime);\n                    // Parse the date string (format: \"2025/6/5 20:23:30\")\n                    const [datePart, timePart] = data.data.effectiveTime.split(\" \");\n                    const [year, month, day] = datePart.split(\"/\");\n                    const [hours, minutes, seconds] = timePart.split(\":\");\n                    console.log(\"\\uD83D\\uDCC5 [Scraper] Parsed components:\", {\n                        year,\n                        month,\n                        day,\n                        hours,\n                        minutes,\n                        seconds\n                    });\n                    // Create date with local time\n                    endDate = new Date(parseInt(year), parseInt(month) - 1, parseInt(day), parseInt(hours), parseInt(minutes), parseInt(seconds));\n                    console.log(\"\\uD83D\\uDCC5 [Scraper] Initial date:\", endDate.toString());\n                    // Subtract 12 hours\n                    endDate.setHours(endDate.getHours() - 12);\n                    console.log(\"\\uD83D\\uDCC5 [Scraper] After subtracting 12 hours:\", endDate.toString());\n                    // Format the date for the form (YYYY-MM-DDThh:mm) while preserving local time\n                    const year2 = endDate.getFullYear();\n                    const month2 = String(endDate.getMonth() + 1).padStart(2, \"0\");\n                    const day2 = String(endDate.getDate()).padStart(2, \"0\");\n                    const hours2 = String(endDate.getHours()).padStart(2, \"0\");\n                    const minutes2 = String(endDate.getMinutes()).padStart(2, \"0\");\n                    const formattedDate = \"\".concat(year2, \"-\").concat(month2, \"-\").concat(day2, \"T\").concat(hours2, \":\").concat(minutes2);\n                    console.log(\"\\uD83D\\uDCC5 [Scraper] Final formatted date:\", formattedDate);\n                    const result = {\n                        name,\n                        url,\n                        imageUrl,\n                        sellerUrl,\n                        bid: 0,\n                        currentBid,\n                        market: 0,\n                        date: formattedDate\n                    };\n                    console.log(\"✅ [Scraper] Extracted data:\", result);\n                    return result;\n                } else {\n                    console.log(\"⚠️ [Scraper] No effectiveTime found in response\");\n                    // Return default date if no effectiveTime found\n                    const result = {\n                        name,\n                        url,\n                        imageUrl,\n                        sellerUrl,\n                        bid: 0,\n                        currentBid,\n                        market: 0,\n                        date: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString().slice(0, 16)\n                    };\n                    return result;\n                }\n            }\n        });\n    // Add more scrapers here as needed\n    }\n    static getInstance() {\n        if (!ScraperService.instance) {\n            ScraperService.instance = new ScraperService();\n        }\n        return ScraperService.instance;\n    }\n    async waitForRateLimit(scraperName) {\n        const scraper = this.scrapers.get(scraperName);\n        if (!(scraper === null || scraper === void 0 ? void 0 : scraper.rateLimit)) return;\n        const now = Date.now();\n        const requests = this.requestCounts.get(scraperName) || [];\n        // Remove old requests outside the time window\n        const validRequests = requests.filter((time)=>now - time < scraper.rateLimit.timeWindow);\n        if (validRequests.length >= scraper.rateLimit.maxRequests) {\n            const oldestRequest = validRequests[0];\n            const waitTime = oldestRequest + scraper.rateLimit.timeWindow - now;\n            console.log(\"Rate limit reached for \".concat(scraperName, \", waiting \").concat(waitTime, \"ms\"));\n            await new Promise((resolve)=>setTimeout(resolve, waitTime));\n        }\n        // Update request count\n        this.requestCounts.set(scraperName, [\n            ...validRequests,\n            now\n        ]);\n    }\n    async fetchWithRetry(url, options) {\n        let timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5000;\n        let lastError = null;\n        for(let attempt = 0; attempt < this.MAX_RETRIES; attempt++){\n            try {\n                console.log(\"Fetch attempt \".concat(attempt + 1, \" for \").concat(url));\n                const controller = new AbortController();\n                const id = setTimeout(()=>controller.abort(), timeout);\n                const response = await fetch(url, {\n                    ...options,\n                    signal: controller.signal\n                });\n                clearTimeout(id);\n                console.log(\"Fetch successful for \".concat(url, \", status: \").concat(response.status));\n                return response;\n            } catch (error) {\n                lastError = error;\n                console.error(\"Fetch attempt \".concat(attempt + 1, \" failed:\"), error);\n                if (attempt < this.MAX_RETRIES - 1) {\n                    const delay = this.RETRY_DELAY * Math.pow(2, attempt);\n                    console.log(\"Waiting \".concat(delay, \"ms before retry\"));\n                    await new Promise((resolve)=>setTimeout(resolve, delay));\n                }\n            }\n        }\n        throw lastError || new Error(\"Failed to fetch after retries\");\n    }\n    async handleCardHobbyScrape(url) {\n        var _url_match;\n        console.log(\"\\uD83D\\uDD0D [Scraper] Starting Card Hobby scrape for URL:\", url);\n        // Extract card ID from URL like https://www.cardhobby.com/#/carddetails/67180979\n        const cardId = (_url_match = url.match(/carddetails\\/(\\d+)/)) === null || _url_match === void 0 ? void 0 : _url_match[1];\n        if (!cardId) {\n            console.error(\"❌ [Scraper] Invalid URL format - could not extract card ID\");\n            throw new Error(\"Invalid URL format\");\n        }\n        console.log(\"✅ [Scraper] Extracted card ID:\", cardId);\n        await this.waitForRateLimit(\"cardhobby\");\n        // Get the specific card details using the direct API endpoint\n        const apiUrl = \"https://gatewayapi.cardhobby.com/card/Commodity/DetailCommodity/?memberid=499559&token=b9e22c0e118ce211f9611a818cc5c0b0&operator_id=499559&CommodityID=\".concat(cardId, \"&buyerSource=CA&lag=en&device=Web&version=1&appname=Card+Hobby\");\n        console.log(\"\\uD83C\\uDF10 [Scraper] Fetching card details from:\", apiUrl);\n        try {\n            console.log(\"\\uD83D\\uDCE1 [Scraper] Sending API request...\");\n            const response = await this.fetchWithRetry(apiUrl, {\n                method: \"GET\",\n                headers: {\n                    \"Accept\": \"*/*\",\n                    \"Content-Type\": \"application/json\",\n                    \"Origin\": \"http://localhost:3000\",\n                    \"Referer\": \"http://localhost:3000/\",\n                    \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:139.0) Gecko/20100101 Firefox/139.0\",\n                    \"Accept-Language\": \"en-CA,en-US;q=0.7,en;q=0.3\",\n                    \"Accept-Encoding\": \"gzip, deflate, br, zstd\",\n                    \"Connection\": \"keep-alive\",\n                    \"Sec-Fetch-Dest\": \"empty\",\n                    \"Sec-Fetch-Mode\": \"cors\",\n                    \"Sec-Fetch-Site\": \"cross-site\"\n                },\n                mode: \"cors\",\n                credentials: \"omit\"\n            });\n            if (!response.ok) {\n                console.error(\"❌ [Scraper] API request failed with status:\", response.status);\n                if (response.status === 404) {\n                    throw new Error(\"Card not found. Please verify the card ID is correct.\");\n                }\n                throw new Error(\"API request failed: \".concat(response.status));\n            }\n            console.log(\"✅ [Scraper] API request successful, parsing response...\");\n            const data = await response.json();\n            console.log(\"\\uD83D\\uDCE6 [Scraper] Raw API response:\", data);\n            // Check if the response contains valid data\n            if (!(data === null || data === void 0 ? void 0 : data.data)) {\n                console.error(\"❌ [Scraper] Invalid response format - missing data field\");\n                throw new Error(\"Invalid response format from API\");\n            }\n            console.log(\"✅ [Scraper] Successfully parsed API response\");\n            return data;\n        } catch (error) {\n            console.error(\"❌ [Scraper] Error fetching card details:\", error);\n            throw error;\n        }\n    }\n    isCacheValid(entry) {\n        return Date.now() - entry.timestamp < this.CACHE_DURATION;\n    }\n    async scrapeItem(url) {\n        console.log(\"Starting scrape for URL:\", url);\n        try {\n            // Check cache first\n            const cachedEntry = this.cache.get(url);\n            if (cachedEntry && this.isCacheValid(cachedEntry)) {\n                console.log(\"Returning cached data for:\", url);\n                return cachedEntry.data;\n            }\n            // Find the appropriate scraper for the URL\n            const scraper = Array.from(this.scrapers.values()).find((s)=>s.urlPattern.test(url));\n            if (!scraper) {\n                console.error(\"No scraper found for URL:\", url);\n                throw new Error(\"No scraper available for this URL\");\n            }\n            console.log(\"Found scraper:\", scraper.name);\n            let data;\n            if (scraper.name === \"Card Hobby\") {\n                data = await this.handleCardHobbyScrape(url);\n            } else {\n                console.error(\"Unsupported website:\", url);\n                throw new Error(\"Unsupported website\");\n            }\n            // Validate the data\n            if (!scraper.validateData(data)) {\n                console.error(\"Invalid data received:\", data);\n                throw new Error(\"Invalid data received from scraper\");\n            }\n            // Extract data using the scraper's extractData function\n            const extractedData = await scraper.extractData(url, data);\n            // Cache the result\n            this.cache.set(url, {\n                data: extractedData,\n                timestamp: Date.now()\n            });\n            console.log(\"Successfully scraped and cached data for:\", url);\n            return extractedData;\n        } catch (error) {\n            console.error(\"Error scraping item:\", error);\n            if (error instanceof Error) {\n                throw new Error(\"Failed to scrape item details: \".concat(error.message));\n            }\n            throw new Error(\"Failed to scrape item details\");\n        }\n    }\n    // Method to clear cache for a specific URL or all URLs\n    clearCache(url) {\n        if (url) {\n            this.cache.delete(url);\n            console.log(\"Cleared cache for URL:\", url);\n        } else {\n            this.cache.clear();\n            console.log(\"Cleared all cache\");\n        }\n    }\n    constructor(){\n        this.scrapers = new Map();\n        this.cache = new Map();\n        this.requestCounts = new Map();\n        this.CACHE_DURATION = 1000 * 60 * 5 // 5 minutes\n        ;\n        this.MAX_RETRIES = 3;\n        this.RETRY_DELAY = 1000 // 1 second\n        ;\n        this.initializeScrapers();\n    }\n}\nconst scraper = ScraperService.getInstance();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9zY3JhcGVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFrQkEsTUFBTUE7SUFhSUMscUJBQXFCO1FBQzNCLCtDQUErQztRQUMvQyxNQUFNQywwQkFBMEIsQ0FBQ0M7WUFDL0IsbUVBQW1FO1lBQ25FLE9BQU9BLEtBQUtDLE9BQU8sQ0FBQywrR0FBK0csR0FDakkseUJBQXlCO2FBQ3hCQSxPQUFPLENBQUMsUUFBUSxJQUNqQixjQUFjO2FBQ2JDLElBQUk7UUFDVDtRQUVBLHFCQUFxQjtRQUNyQixJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDLGFBQWE7WUFDN0JDLE1BQU07WUFDTkMsWUFBWTtZQUNaQyxXQUFXO2dCQUNUQyxhQUFhO2dCQUNiQyxZQUFZLE9BQU8sR0FBRyxXQUFXO1lBQ25DO1lBQ0FDLGNBQWMsQ0FBQ0M7b0JBRUdBLFlBQ0ZBLGFBQ0FBO2dCQUhkQyxRQUFRQyxHQUFHLENBQUMsc0RBQTRDRjtnQkFDeEQsTUFBTUcsVUFBVUgsQ0FBQUEsaUJBQUFBLDRCQUFBQSxhQUFBQSxLQUFNQSxJQUFJLGNBQVZBLGlDQUFBQSxXQUFZSSxNQUFNLEtBQUksUUFDL0IsUUFBT0osaUJBQUFBLDRCQUFBQSxjQUFBQSxLQUFNQSxJQUFJLGNBQVZBLGtDQUFBQSxZQUFZSyxTQUFTLE1BQUssWUFDakMsUUFBT0wsaUJBQUFBLDRCQUFBQSxjQUFBQSxLQUFNQSxJQUFJLGNBQVZBLGtDQUFBQSxZQUFZTSxLQUFLLE1BQUs7Z0JBQ3BDTCxRQUFRQyxHQUFHLENBQUMsa0NBQWtDQztnQkFDOUMsT0FBT0E7WUFDVDtZQUNBSSxhQUFhLE9BQU9DLEtBQWFSO29CQUtkQSxZQUNhQSxhQUNiQSxhQU1DQSxhQU1EQSxhQUdiQTtnQkFyQkpDLFFBQVFDLEdBQUcsQ0FBQyxzREFBNENGO2dCQUN4REMsUUFBUUMsR0FBRyxDQUFDLHVEQUE2Q08sS0FBS0MsU0FBUyxDQUFDVixNQUFNLE1BQU07Z0JBQ3BGQyxRQUFR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WUFDbEJQLFFBQVFDLEdBQUcsQ0FBQywwQkFBMEJNO1FBQ3hDLE9BQU87WUFDTCxJQUFJLENBQUN3RyxLQUFLLENBQUNXLEtBQUs7WUFDaEIxSCxRQUFRQyxHQUFHLENBQUM7UUFDZDtJQUNGO0lBN1RBLGFBQXNCO2FBUGRWLFdBQXVDLElBQUlvSTthQUMzQ1osUUFBaUMsSUFBSVk7YUFDckMzRCxnQkFBdUMsSUFBSTJEO2FBQ2xDZixpQkFBaUIsT0FBTyxLQUFLLEVBQUcsWUFBWTs7YUFDNUM3QixjQUFjO2FBQ2RZLGNBQWMsS0FBTSxXQUFXOztRQUc5QyxJQUFJLENBQUN6RyxrQkFBa0I7SUFDekI7QUE0VEY7QUFFTyxNQUFNMkUsVUFBVTVFLGVBQWV3RSxXQUFXLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NlcnZpY2VzL3NjcmFwZXIudHM/M2MwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJdGVtIH0gZnJvbSAnQC90eXBlcy9pdGVtJztcblxuaW50ZXJmYWNlIFNjcmFwZXJDb25maWcge1xuICBuYW1lOiBzdHJpbmc7XG4gIHVybFBhdHRlcm46IFJlZ0V4cDtcbiAgZXh0cmFjdERhdGE6ICh1cmw6IHN0cmluZywgZGF0YTogYW55KSA9PiBQcm9taXNlPE9taXQ8SXRlbSwgJ2lkJz4+O1xuICB2YWxpZGF0ZURhdGE6IChkYXRhOiBhbnkpID0+IGJvb2xlYW47XG4gIHJhdGVMaW1pdD86IHtcbiAgICBtYXhSZXF1ZXN0czogbnVtYmVyO1xuICAgIHRpbWVXaW5kb3c6IG51bWJlcjsgLy8gaW4gbWlsbGlzZWNvbmRzXG4gIH07XG59XG5cbmludGVyZmFjZSBDYWNoZUVudHJ5IHtcbiAgZGF0YTogT21pdDxJdGVtLCAnaWQnPjtcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmNsYXNzIFNjcmFwZXJTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFNjcmFwZXJTZXJ2aWNlO1xuICBwcml2YXRlIHNjcmFwZXJzOiBNYXA8c3RyaW5nLCBTY3JhcGVyQ29uZmlnPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBjYWNoZTogTWFwPHN0cmluZywgQ2FjaGVFbnRyeT4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgcmVxdWVzdENvdW50czogTWFwPHN0cmluZywgbnVtYmVyW10+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHJlYWRvbmx5IENBQ0hFX0RVUkFUSU9OID0gMTAwMCAqIDYwICogNTsgLy8gNSBtaW51dGVzXG4gIHByaXZhdGUgcmVhZG9ubHkgTUFYX1JFVFJJRVMgPSAzO1xuICBwcml2YXRlIHJlYWRvbmx5IFJFVFJZX0RFTEFZID0gMTAwMDsgLy8gMSBzZWNvbmRcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZVNjcmFwZXJzKCk7XG4gIH1cblxuICBwcml2YXRlIGluaXRpYWxpemVTY3JhcGVycygpIHtcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gcmVtb3ZlIENoaW5lc2UgY2hhcmFjdGVyc1xuICAgIGNvbnN0IHJlbW92ZUNoaW5lc2VDaGFyYWN0ZXJzID0gKHRleHQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICAvLyBSZW1vdmUgQ2hpbmVzZSBjaGFyYWN0ZXJzIChVbmljb2RlIHJhbmdlIGZvciBDaGluZXNlIGNoYXJhY3RlcnMpXG4gICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9bXFx1NGUwMC1cXHU5ZmZmXFx1MzQwMC1cXHU0ZGJmXFx1ZjkwMC1cXHVmYWZmXFx1ZjkwMC1cXHVmYWZmXFx1MzMwMC1cXHUzM2ZmXFx1ZmUzMC1cXHVmZTRmXFx1ZjkwMC1cXHVmYWZmXFx1ZmYwMC1cXHVmZmVmXS9nLCAnJylcbiAgICAgICAgLy8gUmVtb3ZlIG11bHRpcGxlIHNwYWNlc1xuICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpXG4gICAgICAgIC8vIFRyaW0gc3BhY2VzXG4gICAgICAgIC50cmltKCk7XG4gICAgfTtcblxuICAgIC8vIENhcmQgSG9iYnkgU2NyYXBlclxuICAgIHRoaXMuc2NyYXBlcnMuc2V0KCdjYXJkaG9iYnknLCB7XG4gICAgICBuYW1lOiAnQ2FyZCBIb2JieScsXG4gICAgICB1cmxQYXR0ZXJuOiAvY2FyZGhvYmJ5XFwuY29tXFwvI1xcL2NhcmRkZXRhaWxzXFwvXFxkKy8sXG4gICAgICByYXRlTGltaXQ6IHtcbiAgICAgICAgbWF4UmVxdWVzdHM6IDEwLFxuICAgICAgICB0aW1lV2luZG93OiAxMDAwICogNjAgLy8gMSBtaW51dGVcbiAgICAgIH0sXG4gICAgICB2YWxpZGF0ZURhdGE6IChkYXRhOiBhbnkpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ/CflI0gW1NjcmFwZXJdIFZhbGlkYXRpbmcgQ2FyZCBIb2JieSBkYXRhOicsIGRhdGEpO1xuICAgICAgICBjb25zdCBpc1ZhbGlkID0gZGF0YT8uZGF0YT8uVGl0SW1nICE9IG51bGwgJiYgXG4gICAgICAgICAgICAgICB0eXBlb2YgZGF0YT8uZGF0YT8uVVNEX1ByaWNlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgdHlwZW9mIGRhdGE/LmRhdGE/LlRpdGxlID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBbU2NyYXBlcl0gVmFsaWRhdGlvbiByZXN1bHQ6JywgaXNWYWxpZCk7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgICAgfSxcbiAgICAgIGV4dHJhY3REYXRhOiBhc3luYyAodXJsOiBzdHJpbmcsIGRhdGE6IGFueSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBbU2NyYXBlcl0gRXh0cmFjdGluZyBDYXJkIEhvYmJ5IGRhdGE6JywgZGF0YSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFtTY3JhcGVyXSBGdWxsIEFQSSByZXNwb25zZSBzdHJ1Y3R1cmU6JywgSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMikpO1xuICAgICAgICBjb25zb2xlLmxvZygn8J+UjSBbU2NyYXBlcl0gRGF0YSBvYmplY3Qga2V5czonLCBPYmplY3Qua2V5cyhkYXRhLmRhdGEgfHwge30pKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGltYWdlVXJsID0gZGF0YS5kYXRhPy5UaXRJbWcgfHwgJyc7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCaWQgPSBwYXJzZUZsb2F0KGRhdGEuZGF0YT8uVVNEX1ByaWNlKSB8fCAwO1xuICAgICAgICBjb25zdCByYXdUaXRsZSA9IGRhdGEuZGF0YT8uVGl0bGUgfHwgJ1Vua25vd24gSXRlbSc7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OdIFtTY3JhcGVyXSBSYXcgdGl0bGU6JywgcmF3VGl0bGUpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbmFtZSA9IHJlbW92ZUNoaW5lc2VDaGFyYWN0ZXJzKHJhd1RpdGxlKTtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk50gW1NjcmFwZXJdIENsZWFuZWQgdGl0bGU6JywgbmFtZSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBzZWxsZXJVcmwgPSBkYXRhLmRhdGE/LlNlbGxSZWFsTmFtZSA/IGBodHRwczovL3d3dy5jYXJkaG9iYnkuY29tLyMvc2hvcC8ke2RhdGEuZGF0YS5TZWxsUmVhbE5hbWV9YCA6IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG5cbiAgICAgICAgLy8gUGFyc2UgdGhlIGVmZmVjdGl2ZVRpbWUgYW5kIHN1YnRyYWN0IDEyIGhvdXJzXG4gICAgICAgIGxldCBlbmREYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc29sZS5sb2coJ/CflI0gW1NjcmFwZXJdIENoZWNraW5nIGZvciBlZmZlY3RpdmVUaW1lIGluIGRhdGE6Jywge1xuICAgICAgICAgIGhhc0RhdGE6ICEhZGF0YS5kYXRhLFxuICAgICAgICAgIGVmZmVjdGl2ZVRpbWU6IGRhdGEuZGF0YT8uZWZmZWN0aXZlVGltZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRhdGEuZGF0YT8uZWZmZWN0aXZlVGltZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OFIFtTY3JhcGVyXSBSYXcgZWZmZWN0aXZlVGltZTonLCBkYXRhLmRhdGEuZWZmZWN0aXZlVGltZSk7XG4gICAgICAgICAgLy8gUGFyc2UgdGhlIGRhdGUgc3RyaW5nIChmb3JtYXQ6IFwiMjAyNS82LzUgMjA6MjM6MzBcIilcbiAgICAgICAgICBjb25zdCBbZGF0ZVBhcnQsIHRpbWVQYXJ0XSA9IGRhdGEuZGF0YS5lZmZlY3RpdmVUaW1lLnNwbGl0KCcgJyk7XG4gICAgICAgICAgY29uc3QgW3llYXIsIG1vbnRoLCBkYXldID0gZGF0ZVBhcnQuc3BsaXQoJy8nKTtcbiAgICAgICAgICBjb25zdCBbaG91cnMsIG1pbnV0ZXMsIHNlY29uZHNdID0gdGltZVBhcnQuc3BsaXQoJzonKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+ThSBbU2NyYXBlcl0gUGFyc2VkIGNvbXBvbmVudHM6Jywge1xuICAgICAgICAgICAgeWVhcixcbiAgICAgICAgICAgIG1vbnRoLFxuICAgICAgICAgICAgZGF5LFxuICAgICAgICAgICAgaG91cnMsXG4gICAgICAgICAgICBtaW51dGVzLFxuICAgICAgICAgICAgc2Vjb25kc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gQ3JlYXRlIGRhdGUgd2l0aCBsb2NhbCB0aW1lXG4gICAgICAgICAgZW5kRGF0ZSA9IG5ldyBEYXRlKFxuICAgICAgICAgICAgcGFyc2VJbnQoeWVhciksXG4gICAgICAgICAgICBwYXJzZUludChtb250aCkgLSAxLCAvLyBKYXZhU2NyaXB0IG1vbnRocyBhcmUgMC1iYXNlZFxuICAgICAgICAgICAgcGFyc2VJbnQoZGF5KSxcbiAgICAgICAgICAgIHBhcnNlSW50KGhvdXJzKSxcbiAgICAgICAgICAgIHBhcnNlSW50KG1pbnV0ZXMpLFxuICAgICAgICAgICAgcGFyc2VJbnQoc2Vjb25kcylcbiAgICAgICAgICApO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OFIFtTY3JhcGVyXSBJbml0aWFsIGRhdGU6JywgZW5kRGF0ZS50b1N0cmluZygpKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTdWJ0cmFjdCAxMiBob3Vyc1xuICAgICAgICAgIGVuZERhdGUuc2V0SG91cnMoZW5kRGF0ZS5nZXRIb3VycygpIC0gMTIpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OFIFtTY3JhcGVyXSBBZnRlciBzdWJ0cmFjdGluZyAxMiBob3VyczonLCBlbmREYXRlLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgLy8gRm9ybWF0IHRoZSBkYXRlIGZvciB0aGUgZm9ybSAoWVlZWS1NTS1ERFRoaDptbSkgd2hpbGUgcHJlc2VydmluZyBsb2NhbCB0aW1lXG4gICAgICAgICAgY29uc3QgeWVhcjIgPSBlbmREYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgY29uc3QgbW9udGgyID0gU3RyaW5nKGVuZERhdGUuZ2V0TW9udGgoKSArIDEpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgICAgY29uc3QgZGF5MiA9IFN0cmluZyhlbmREYXRlLmdldERhdGUoKSkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgICAgICBjb25zdCBob3VyczIgPSBTdHJpbmcoZW5kRGF0ZS5nZXRIb3VycygpKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICAgIGNvbnN0IG1pbnV0ZXMyID0gU3RyaW5nKGVuZERhdGUuZ2V0TWludXRlcygpKS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZERhdGUgPSBgJHt5ZWFyMn0tJHttb250aDJ9LSR7ZGF5Mn1UJHtob3VyczJ9OiR7bWludXRlczJ9YDtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+ThSBbU2NyYXBlcl0gRmluYWwgZm9ybWF0dGVkIGRhdGU6JywgZm9ybWF0dGVkRGF0ZSk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgaW1hZ2VVcmwsXG4gICAgICAgICAgICBzZWxsZXJVcmwsXG4gICAgICAgICAgICBiaWQ6IDAsXG4gICAgICAgICAgICBjdXJyZW50QmlkLFxuICAgICAgICAgICAgbWFya2V0OiAwLFxuICAgICAgICAgICAgZGF0ZTogZm9ybWF0dGVkRGF0ZSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgW1NjcmFwZXJdIEV4dHJhY3RlZCBkYXRhOicsIHJlc3VsdCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pqg77iPIFtTY3JhcGVyXSBObyBlZmZlY3RpdmVUaW1lIGZvdW5kIGluIHJlc3BvbnNlJyk7XG4gICAgICAgICAgLy8gUmV0dXJuIGRlZmF1bHQgZGF0ZSBpZiBubyBlZmZlY3RpdmVUaW1lIGZvdW5kXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIGltYWdlVXJsLFxuICAgICAgICAgICAgc2VsbGVyVXJsLFxuICAgICAgICAgICAgYmlkOiAwLFxuICAgICAgICAgICAgY3VycmVudEJpZCxcbiAgICAgICAgICAgIG1hcmtldDogMCxcbiAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKERhdGUubm93KCkgKyAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDE2KSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEFkZCBtb3JlIHNjcmFwZXJzIGhlcmUgYXMgbmVlZGVkXG4gIH1cblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogU2NyYXBlclNlcnZpY2Uge1xuICAgIGlmICghU2NyYXBlclNlcnZpY2UuaW5zdGFuY2UpIHtcbiAgICAgIFNjcmFwZXJTZXJ2aWNlLmluc3RhbmNlID0gbmV3IFNjcmFwZXJTZXJ2aWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBTY3JhcGVyU2VydmljZS5pbnN0YW5jZTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgd2FpdEZvclJhdGVMaW1pdChzY3JhcGVyTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc2NyYXBlciA9IHRoaXMuc2NyYXBlcnMuZ2V0KHNjcmFwZXJOYW1lKTtcbiAgICBpZiAoIXNjcmFwZXI/LnJhdGVMaW1pdCkgcmV0dXJuO1xuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCByZXF1ZXN0cyA9IHRoaXMucmVxdWVzdENvdW50cy5nZXQoc2NyYXBlck5hbWUpIHx8IFtdO1xuICAgIFxuICAgIC8vIFJlbW92ZSBvbGQgcmVxdWVzdHMgb3V0c2lkZSB0aGUgdGltZSB3aW5kb3dcbiAgICBjb25zdCB2YWxpZFJlcXVlc3RzID0gcmVxdWVzdHMuZmlsdGVyKHRpbWUgPT4gbm93IC0gdGltZSA8IHNjcmFwZXIucmF0ZUxpbWl0IS50aW1lV2luZG93KTtcbiAgICBcbiAgICBpZiAodmFsaWRSZXF1ZXN0cy5sZW5ndGggPj0gc2NyYXBlci5yYXRlTGltaXQhLm1heFJlcXVlc3RzKSB7XG4gICAgICBjb25zdCBvbGRlc3RSZXF1ZXN0ID0gdmFsaWRSZXF1ZXN0c1swXTtcbiAgICAgIGNvbnN0IHdhaXRUaW1lID0gb2xkZXN0UmVxdWVzdCArIHNjcmFwZXIucmF0ZUxpbWl0IS50aW1lV2luZG93IC0gbm93O1xuICAgICAgY29uc29sZS5sb2coYFJhdGUgbGltaXQgcmVhY2hlZCBmb3IgJHtzY3JhcGVyTmFtZX0sIHdhaXRpbmcgJHt3YWl0VGltZX1tc2ApO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHdhaXRUaW1lKSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHJlcXVlc3QgY291bnRcbiAgICB0aGlzLnJlcXVlc3RDb3VudHMuc2V0KHNjcmFwZXJOYW1lLCBbLi4udmFsaWRSZXF1ZXN0cywgbm93XSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZldGNoV2l0aFJldHJ5KHVybDogc3RyaW5nLCBvcHRpb25zOiBSZXF1ZXN0SW5pdCwgdGltZW91dCA9IDUwMDApOiBQcm9taXNlPFJlc3BvbnNlPiB7XG4gICAgbGV0IGxhc3RFcnJvcjogRXJyb3IgfCBudWxsID0gbnVsbDtcbiAgICBcbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IHRoaXMuTUFYX1JFVFJJRVM7IGF0dGVtcHQrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYEZldGNoIGF0dGVtcHQgJHthdHRlbXB0ICsgMX0gZm9yICR7dXJsfWApO1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCBpZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KTtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBGZXRjaCBzdWNjZXNzZnVsIGZvciAke3VybH0sIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxhc3RFcnJvciA9IGVycm9yIGFzIEVycm9yO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBGZXRjaCBhdHRlbXB0ICR7YXR0ZW1wdCArIDF9IGZhaWxlZDpgLCBlcnJvcik7XG4gICAgICAgIGlmIChhdHRlbXB0IDwgdGhpcy5NQVhfUkVUUklFUyAtIDEpIHtcbiAgICAgICAgICBjb25zdCBkZWxheSA9IHRoaXMuUkVUUllfREVMQVkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgV2FpdGluZyAke2RlbGF5fW1zIGJlZm9yZSByZXRyeWApO1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbGFzdEVycm9yIHx8IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIGFmdGVyIHJldHJpZXMnKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlQ2FyZEhvYmJ5U2NyYXBlKHVybDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zb2xlLmxvZygn8J+UjSBbU2NyYXBlcl0gU3RhcnRpbmcgQ2FyZCBIb2JieSBzY3JhcGUgZm9yIFVSTDonLCB1cmwpO1xuICAgIC8vIEV4dHJhY3QgY2FyZCBJRCBmcm9tIFVSTCBsaWtlIGh0dHBzOi8vd3d3LmNhcmRob2JieS5jb20vIy9jYXJkZGV0YWlscy82NzE4MDk3OVxuICAgIGNvbnN0IGNhcmRJZCA9IHVybC5tYXRjaCgvY2FyZGRldGFpbHNcXC8oXFxkKykvKT8uWzFdO1xuICAgIGlmICghY2FyZElkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgW1NjcmFwZXJdIEludmFsaWQgVVJMIGZvcm1hdCAtIGNvdWxkIG5vdCBleHRyYWN0IGNhcmQgSUQnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBVUkwgZm9ybWF0Jyk7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKCfinIUgW1NjcmFwZXJdIEV4dHJhY3RlZCBjYXJkIElEOicsIGNhcmRJZCk7XG5cbiAgICBhd2FpdCB0aGlzLndhaXRGb3JSYXRlTGltaXQoJ2NhcmRob2JieScpO1xuXG4gICAgLy8gR2V0IHRoZSBzcGVjaWZpYyBjYXJkIGRldGFpbHMgdXNpbmcgdGhlIGRpcmVjdCBBUEkgZW5kcG9pbnRcbiAgICBjb25zdCBhcGlVcmwgPSBgaHR0cHM6Ly9nYXRld2F5YXBpLmNhcmRob2JieS5jb20vY2FyZC9Db21tb2RpdHkvRGV0YWlsQ29tbW9kaXR5Lz9tZW1iZXJpZD00OTk1NTkmdG9rZW49YjllMjJjMGUxMThjZTIxMWY5NjExYTgxOGNjNWMwYjAmb3BlcmF0b3JfaWQ9NDk5NTU5JkNvbW1vZGl0eUlEPSR7Y2FyZElkfSZidXllclNvdXJjZT1DQSZsYWc9ZW4mZGV2aWNlPVdlYiZ2ZXJzaW9uPTEmYXBwbmFtZT1DYXJkK0hvYmJ5YDtcbiAgICBjb25zb2xlLmxvZygn8J+MkCBbU2NyYXBlcl0gRmV0Y2hpbmcgY2FyZCBkZXRhaWxzIGZyb206JywgYXBpVXJsKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/Cfk6EgW1NjcmFwZXJdIFNlbmRpbmcgQVBJIHJlcXVlc3QuLi4nKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaFdpdGhSZXRyeShhcGlVcmwsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBY2NlcHQnOiAnKi8qJyxcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdPcmlnaW4nOiAnaHR0cDovL2xvY2FsaG9zdDozMDAwJyxcbiAgICAgICAgICAnUmVmZXJlcic6ICdodHRwOi8vbG9jYWxob3N0OjMwMDAvJyxcbiAgICAgICAgICAnVXNlci1BZ2VudCc6ICdNb3ppbGxhLzUuMCAoTWFjaW50b3NoOyBJbnRlbCBNYWMgT1MgWCAxMC4xNTsgcnY6MTM5LjApIEdlY2tvLzIwMTAwMTAxIEZpcmVmb3gvMTM5LjAnLFxuICAgICAgICAgICdBY2NlcHQtTGFuZ3VhZ2UnOiAnZW4tQ0EsZW4tVVM7cT0wLjcsZW47cT0wLjMnLFxuICAgICAgICAgICdBY2NlcHQtRW5jb2RpbmcnOiAnZ3ppcCwgZGVmbGF0ZSwgYnIsIHpzdGQnLFxuICAgICAgICAgICdDb25uZWN0aW9uJzogJ2tlZXAtYWxpdmUnLFxuICAgICAgICAgICdTZWMtRmV0Y2gtRGVzdCc6ICdlbXB0eScsXG4gICAgICAgICAgJ1NlYy1GZXRjaC1Nb2RlJzogJ2NvcnMnLFxuICAgICAgICAgICdTZWMtRmV0Y2gtU2l0ZSc6ICdjcm9zcy1zaXRlJ1xuICAgICAgICB9LFxuICAgICAgICBtb2RlOiAnY29ycycsXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnb21pdCdcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBbU2NyYXBlcl0gQVBJIHJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FyZCBub3QgZm91bmQuIFBsZWFzZSB2ZXJpZnkgdGhlIGNhcmQgSUQgaXMgY29ycmVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSByZXF1ZXN0IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCfinIUgW1NjcmFwZXJdIEFQSSByZXF1ZXN0IHN1Y2Nlc3NmdWwsIHBhcnNpbmcgcmVzcG9uc2UuLi4nKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZygn8J+TpiBbU2NyYXBlcl0gUmF3IEFQSSByZXNwb25zZTonLCBkYXRhKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlc3BvbnNlIGNvbnRhaW5zIHZhbGlkIGRhdGFcbiAgICAgIGlmICghZGF0YT8uZGF0YSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgW1NjcmFwZXJdIEludmFsaWQgcmVzcG9uc2UgZm9ybWF0IC0gbWlzc2luZyBkYXRhIGZpZWxkJyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZSBmb3JtYXQgZnJvbSBBUEknKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ+KchSBbU2NyYXBlcl0gU3VjY2Vzc2Z1bGx5IHBhcnNlZCBBUEkgcmVzcG9uc2UnKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgW1NjcmFwZXJdIEVycm9yIGZldGNoaW5nIGNhcmQgZGV0YWlsczonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGlzQ2FjaGVWYWxpZChlbnRyeTogQ2FjaGVFbnRyeSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gZW50cnkudGltZXN0YW1wIDwgdGhpcy5DQUNIRV9EVVJBVElPTjtcbiAgfVxuXG4gIGFzeW5jIHNjcmFwZUl0ZW0odXJsOiBzdHJpbmcpOiBQcm9taXNlPE9taXQ8SXRlbSwgJ2lkJz4+IHtcbiAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgc2NyYXBlIGZvciBVUkw6JywgdXJsKTtcbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3RcbiAgICAgIGNvbnN0IGNhY2hlZEVudHJ5ID0gdGhpcy5jYWNoZS5nZXQodXJsKTtcbiAgICAgIGlmIChjYWNoZWRFbnRyeSAmJiB0aGlzLmlzQ2FjaGVWYWxpZChjYWNoZWRFbnRyeSkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1JldHVybmluZyBjYWNoZWQgZGF0YSBmb3I6JywgdXJsKTtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEVudHJ5LmRhdGE7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgdGhlIGFwcHJvcHJpYXRlIHNjcmFwZXIgZm9yIHRoZSBVUkxcbiAgICAgIGNvbnN0IHNjcmFwZXIgPSBBcnJheS5mcm9tKHRoaXMuc2NyYXBlcnMudmFsdWVzKCkpLmZpbmQocyA9PiBzLnVybFBhdHRlcm4udGVzdCh1cmwpKTtcbiAgICAgIFxuICAgICAgaWYgKCFzY3JhcGVyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIHNjcmFwZXIgZm91bmQgZm9yIFVSTDonLCB1cmwpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNjcmFwZXIgYXZhaWxhYmxlIGZvciB0aGlzIFVSTCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnRm91bmQgc2NyYXBlcjonLCBzY3JhcGVyLm5hbWUpO1xuXG4gICAgICBsZXQgZGF0YTtcbiAgICAgIGlmIChzY3JhcGVyLm5hbWUgPT09ICdDYXJkIEhvYmJ5Jykge1xuICAgICAgICBkYXRhID0gYXdhaXQgdGhpcy5oYW5kbGVDYXJkSG9iYnlTY3JhcGUodXJsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Vuc3VwcG9ydGVkIHdlYnNpdGU6JywgdXJsKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB3ZWJzaXRlJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZhbGlkYXRlIHRoZSBkYXRhXG4gICAgICBpZiAoIXNjcmFwZXIudmFsaWRhdGVEYXRhKGRhdGEpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgZGF0YSByZWNlaXZlZDonLCBkYXRhKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGEgcmVjZWl2ZWQgZnJvbSBzY3JhcGVyJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEV4dHJhY3QgZGF0YSB1c2luZyB0aGUgc2NyYXBlcidzIGV4dHJhY3REYXRhIGZ1bmN0aW9uXG4gICAgICBjb25zdCBleHRyYWN0ZWREYXRhID0gYXdhaXQgc2NyYXBlci5leHRyYWN0RGF0YSh1cmwsIGRhdGEpO1xuXG4gICAgICAvLyBDYWNoZSB0aGUgcmVzdWx0XG4gICAgICB0aGlzLmNhY2hlLnNldCh1cmwsIHtcbiAgICAgICAgZGF0YTogZXh0cmFjdGVkRGF0YSxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSBzY3JhcGVkIGFuZCBjYWNoZWQgZGF0YSBmb3I6JywgdXJsKTtcbiAgICAgIHJldHVybiBleHRyYWN0ZWREYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzY3JhcGluZyBpdGVtOicsIGVycm9yKTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHNjcmFwZSBpdGVtIGRldGFpbHM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNjcmFwZSBpdGVtIGRldGFpbHMnKTtcbiAgICB9XG4gIH1cblxuICAvLyBNZXRob2QgdG8gY2xlYXIgY2FjaGUgZm9yIGEgc3BlY2lmaWMgVVJMIG9yIGFsbCBVUkxzXG4gIGNsZWFyQ2FjaGUodXJsPzogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHVybCkge1xuICAgICAgdGhpcy5jYWNoZS5kZWxldGUodXJsKTtcbiAgICAgIGNvbnNvbGUubG9nKCdDbGVhcmVkIGNhY2hlIGZvciBVUkw6JywgdXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYWNoZS5jbGVhcigpO1xuICAgICAgY29uc29sZS5sb2coJ0NsZWFyZWQgYWxsIGNhY2hlJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzY3JhcGVyID0gU2NyYXBlclNlcnZpY2UuZ2V0SW5zdGFuY2UoKTsgIl0sIm5hbWVzIjpbIlNjcmFwZXJTZXJ2aWNlIiwiaW5pdGlhbGl6ZVNjcmFwZXJzIiwicmVtb3ZlQ2hpbmVzZUNoYXJhY3RlcnMiLCJ0ZXh0IiwicmVwbGFjZSIsInRyaW0iLCJzY3JhcGVycyIsInNldCIsIm5hbWUiLCJ1cmxQYXR0ZXJuIiwicmF0ZUxpbWl0IiwibWF4UmVxdWVzdHMiLCJ0aW1lV2luZG93IiwidmFsaWRhdGVEYXRhIiwiZGF0YSIsImNvbnNvbGUiLCJsb2ciLCJpc1ZhbGlkIiwiVGl0SW1nIiwiVVNEX1ByaWNlIiwiVGl0bGUiLCJleHRyYWN0RGF0YSIsInVybCIsIkpTT04iLCJzdHJpbmdpZnkiLCJPYmplY3QiLCJrZXlzIiwiaW1hZ2VVcmwiLCJjdXJyZW50QmlkIiwicGFyc2VGbG9hdCIsInJhd1RpdGxlIiwic2VsbGVyVXJsIiwiU2VsbFJlYWxOYW1lIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJlbmREYXRlIiwiRGF0ZSIsImhhc0RhdGEiLCJlZmZlY3RpdmVUaW1lIiwiZGF0ZVBhcnQiLCJ0aW1lUGFydCIsInNwbGl0IiwieWVhciIsIm1vbnRoIiwiZGF5IiwiaG91cnMiLCJtaW51dGVzIiwic2Vjb25kcyIsInBhcnNlSW50IiwidG9TdHJpbmciLCJzZXRIb3VycyIsImdldEhvdXJzIiwieWVhcjIiLCJnZXRGdWxsWWVhciIsIm1vbnRoMiIsIlN0cmluZyIsImdldE1vbnRoIiwicGFkU3RhcnQiLCJkYXkyIiwiZ2V0RGF0ZSIsImhvdXJzMiIsIm1pbnV0ZXMyIiwiZ2V0TWludXRlcyIsImZvcm1hdHRlZERhdGUiLCJyZXN1bHQiLCJiaWQiLCJtYXJrZXQiLCJkYXRlIiwibm93IiwidG9JU09TdHJpbmciLCJzbGljZSIsImdldEluc3RhbmNlIiwiaW5zdGFuY2UiLCJ3YWl0Rm9yUmF0ZUxpbWl0Iiwic2NyYXBlck5hbWUiLCJzY3JhcGVyIiwiZ2V0IiwicmVxdWVzdHMiLCJyZXF1ZXN0Q291bnRzIiwidmFsaWRSZXF1ZXN0cyIsImZpbHRlciIsInRpbWUiLCJsZW5ndGgiLCJvbGRlc3RSZXF1ZXN0Iiwid2FpdFRpbWUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJmZXRjaFdpdGhSZXRyeSIsIm9wdGlvbnMiLCJ0aW1lb3V0IiwibGFzdEVycm9yIiwiYXR0ZW1wdCIsIk1BWF9SRVRSSUVTIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsImlkIiwiYWJvcnQiLCJyZXNwb25zZSIsImZldGNoIiwic2lnbmFsIiwiY2xlYXJUaW1lb3V0Iiwic3RhdHVzIiwiZXJyb3IiLCJkZWxheSIsIlJFVFJZX0RFTEFZIiwiTWF0aCIsInBvdyIsIkVycm9yIiwiaGFuZGxlQ2FyZEhvYmJ5U2NyYXBlIiwiY2FyZElkIiwibWF0Y2giLCJhcGlVcmwiLCJtZXRob2QiLCJoZWFkZXJzIiwibW9kZSIsImNyZWRlbnRpYWxzIiwib2siLCJqc29uIiwiaXNDYWNoZVZhbGlkIiwiZW50cnkiLCJ0aW1lc3RhbXAiLCJDQUNIRV9EVVJBVElPTiIsInNjcmFwZUl0ZW0iLCJjYWNoZWRFbnRyeSIsImNhY2hlIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiZmluZCIsInMiLCJ0ZXN0IiwiZXh0cmFjdGVkRGF0YSIsIm1lc3NhZ2UiLCJjbGVhckNhY2hlIiwiZGVsZXRlIiwiY2xlYXIiLCJNYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/scraper.ts\n"));

/***/ })

});