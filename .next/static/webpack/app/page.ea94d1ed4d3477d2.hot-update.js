"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/services/scraper.ts":
/*!*********************************!*\
  !*** ./src/services/scraper.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scraperService: function() { return /* binding */ scraperService; }\n/* harmony export */ });\nclass ScraperService {\n    initializeScrapers() {\n        // Card Hobby Scraper\n        this.scrapers.set(\"cardhobby\", {\n            name: \"Card Hobby\",\n            urlPattern: /cardhobby\\.com\\.cn/,\n            extractData: async (url, data)=>{\n                var _data_data, _data_data1, _data_data2, _data_data3;\n                const imageUrl = ((_data_data = data.data) === null || _data_data === void 0 ? void 0 : _data_data.imageUrl) || \"\";\n                const currentBid = ((_data_data1 = data.data) === null || _data_data1 === void 0 ? void 0 : _data_data1.price) || 0;\n                const name = ((_data_data2 = data.data) === null || _data_data2 === void 0 ? void 0 : _data_data2.title) || \"Unknown Item\";\n                const sellerUrl = ((_data_data3 = data.data) === null || _data_data3 === void 0 ? void 0 : _data_data3.sellerUrl) || window.location.origin;\n                return {\n                    name,\n                    url,\n                    imageUrl,\n                    sellerUrl,\n                    bid: 0,\n                    currentBid,\n                    market: 0,\n                    date: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()\n                };\n            }\n        });\n    // Add more scrapers here as needed\n    }\n    static getInstance() {\n        if (!ScraperService.instance) {\n            ScraperService.instance = new ScraperService();\n        }\n        return ScraperService.instance;\n    }\n    async fetchWithTimeout(url, options) {\n        let timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5000;\n        const controller = new AbortController();\n        const id = setTimeout(()=>controller.abort(), timeout);\n        try {\n            const response = await fetch(url, {\n                ...options,\n                signal: controller.signal\n            });\n            clearTimeout(id);\n            return response;\n        } catch (error) {\n            clearTimeout(id);\n            throw error;\n        }\n    }\n    async handleCardHobbyScrape(url) {\n        const cardId = url.split(\"/\").pop();\n        if (!cardId) {\n            throw new Error(\"Invalid URL format\");\n        }\n        // First, negotiate with the SignalR hub\n        const negotiateUrl = \"https://socket.cardhobby.com.cn/hubs/negotiate?cId=\".concat(cardId);\n        const negotiateResponse = await this.fetchWithTimeout(negotiateUrl, {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"*/*\",\n                \"Content-Type\": \"text/plain;charset=UTF-8\",\n                \"Origin\": \"https://www.cardhobby.com\",\n                \"Referer\": \"https://www.cardhobby.com/\",\n                \"X-Requested-With\": \"XMLHttpRequest\"\n            }\n        });\n        if (!negotiateResponse.ok) {\n            throw new Error(\"SignalR negotiation failed: \".concat(negotiateResponse.status));\n        }\n        const negotiateData = await negotiateResponse.json();\n        // Get the specific card details\n        const apiUrl = \"https://gatewayapi.cardhobby.com/card/NewMyCommodity/GetCardDetail?cardId=\".concat(cardId, \"&lag=en&device=Web&version=1&appname=Card+Hobby\");\n        const response = await this.fetchWithTimeout(apiUrl, {\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Origin\": \"https://www.cardhobby.com\",\n                \"Referer\": \"https://www.cardhobby.com/\"\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"API request failed: \".concat(response.status));\n        }\n        return response.json();\n    }\n    async scrapeItem(url) {\n        try {\n            // Find the appropriate scraper for the URL\n            const scraper = Array.from(this.scrapers.values()).find((s)=>s.urlPattern.test(url));\n            if (!scraper) {\n                throw new Error(\"No scraper available for this URL\");\n            }\n            let data;\n            if (scraper.name === \"Card Hobby\") {\n                data = await this.handleCardHobbyScrape(url);\n            } else {\n                throw new Error(\"Unsupported website\");\n            }\n            // Extract data using the scraper's extractData function\n            return await scraper.extractData(url, data);\n        } catch (error) {\n            console.error(\"Error scraping item:\", error);\n            if (error instanceof Error) {\n                throw new Error(\"Failed to scrape item details: \".concat(error.message));\n            }\n            throw new Error(\"Failed to scrape item details\");\n        }\n    }\n    constructor(){\n        this.scrapers = new Map();\n        this.initializeScrapers();\n    }\n}\nconst scraperService = ScraperService.getInstance();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9zY3JhcGVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFRQSxNQUFNQTtJQVFJQyxxQkFBcUI7UUFDM0IscUJBQXFCO1FBQ3JCLElBQUksQ0FBQ0MsUUFBUSxDQUFDQyxHQUFHLENBQUMsYUFBYTtZQUM3QkMsTUFBTTtZQUNOQyxZQUFZO1lBQ1pDLGFBQWEsT0FBT0MsS0FBYUM7b0JBQ2RBLFlBQ0VBLGFBQ05BLGFBQ0tBO2dCQUhsQixNQUFNQyxXQUFXRCxFQUFBQSxhQUFBQSxLQUFLQSxJQUFJLGNBQVRBLGlDQUFBQSxXQUFXQyxRQUFRLEtBQUk7Z0JBQ3hDLE1BQU1DLGFBQWFGLEVBQUFBLGNBQUFBLEtBQUtBLElBQUksY0FBVEEsa0NBQUFBLFlBQVdHLEtBQUssS0FBSTtnQkFDdkMsTUFBTVAsT0FBT0ksRUFBQUEsY0FBQUEsS0FBS0EsSUFBSSxjQUFUQSxrQ0FBQUEsWUFBV0ksS0FBSyxLQUFJO2dCQUNqQyxNQUFNQyxZQUFZTCxFQUFBQSxjQUFBQSxLQUFLQSxJQUFJLGNBQVRBLGtDQUFBQSxZQUFXSyxTQUFTLEtBQUlDLE9BQU9DLFFBQVEsQ0FBQ0MsTUFBTTtnQkFFaEUsT0FBTztvQkFDTFo7b0JBQ0FHO29CQUNBRTtvQkFDQUk7b0JBQ0FJLEtBQUs7b0JBQ0xQO29CQUNBUSxRQUFRO29CQUNSQyxNQUFNLElBQUlDLEtBQUtBLEtBQUtDLEdBQUcsS0FBSyxLQUFLLEtBQUssS0FBSyxNQUFNQyxXQUFXO2dCQUM5RDtZQUNGO1FBQ0Y7SUFFQSxtQ0FBbUM7SUFDckM7SUFFQSxPQUFPQyxjQUE4QjtRQUNuQyxJQUFJLENBQUN2QixlQUFld0IsUUFBUSxFQUFFO1lBQzVCeEIsZUFBZXdCLFFBQVEsR0FBRyxJQUFJeEI7UUFDaEM7UUFDQSxPQUFPQSxlQUFld0IsUUFBUTtJQUNoQztJQUVBLE1BQWNDLGlCQUFpQmxCLEdBQVcsRUFBRW1CLE9BQW9CLEVBQXFDO1lBQW5DQyxVQUFBQSxpRUFBVTtRQUMxRSxNQUFNQyxhQUFhLElBQUlDO1FBQ3ZCLE1BQU1DLEtBQUtDLFdBQVcsSUFBTUgsV0FBV0ksS0FBSyxJQUFJTDtRQUVoRCxJQUFJO1lBQ0YsTUFBTU0sV0FBVyxNQUFNQyxNQUFNM0IsS0FBSztnQkFDaEMsR0FBR21CLE9BQU87Z0JBQ1ZTLFFBQVFQLFdBQVdPLE1BQU07WUFDM0I7WUFDQUMsYUFBYU47WUFDYixPQUFPRztRQUNULEVBQUUsT0FBT0ksT0FBTztZQUNkRCxhQUFhTjtZQUNiLE1BQU1PO1FBQ1I7SUFDRjtJQUVBLE1BQWNDLHNCQUFzQi9CLEdBQVcsRUFBZ0I7UUFDN0QsTUFBTWdDLFNBQVNoQyxJQUFJaUMsS0FBSyxDQUFDLEtBQUtDLEdBQUc7UUFDakMsSUFBSSxDQUFDRixRQUFRO1lBQ1gsTUFBTSxJQUFJRyxNQUFNO1FBQ2xCO1FBRUEsd0NBQXdDO1FBQ3hDLE1BQU1DLGVBQWUsc0RBQTZELE9BQVBKO1FBQzNFLE1BQU1LLG9CQUFvQixNQUFNLElBQUksQ0FBQ25CLGdCQUFnQixDQUFDa0IsY0FBYztZQUNsRUUsUUFBUTtZQUNSQyxTQUFTO2dCQUNQLFVBQVU7Z0JBQ1YsZ0JBQWdCO2dCQUNoQixVQUFVO2dCQUNWLFdBQVc7Z0JBQ1gsb0JBQW9CO1lBQ3RCO1FBQ0Y7UUFFQSxJQUFJLENBQUNGLGtCQUFrQkcsRUFBRSxFQUFFO1lBQ3pCLE1BQU0sSUFBSUwsTUFBTSwrQkFBd0QsT0FBekJFLGtCQUFrQkksTUFBTTtRQUN6RTtRQUVBLE1BQU1DLGdCQUFnQixNQUFNTCxrQkFBa0JNLElBQUk7UUFFbEQsZ0NBQWdDO1FBQ2hDLE1BQU1DLFNBQVMsNkVBQW9GLE9BQVBaLFFBQU87UUFDbkcsTUFBTU4sV0FBVyxNQUFNLElBQUksQ0FBQ1IsZ0JBQWdCLENBQUMwQixRQUFRO1lBQ25ETCxTQUFTO2dCQUNQLFVBQVU7Z0JBQ1YsVUFBVTtnQkFDVixXQUFXO1lBQ2I7UUFDRjtRQUVBLElBQUksQ0FBQ2IsU0FBU2MsRUFBRSxFQUFFO1lBQ2hCLE1BQU0sSUFBSUwsTUFBTSx1QkFBdUMsT0FBaEJULFNBQVNlLE1BQU07UUFDeEQ7UUFFQSxPQUFPZixTQUFTaUIsSUFBSTtJQUN0QjtJQUVBLE1BQU1FLFdBQVc3QyxHQUFXLEVBQTZCO1FBQ3ZELElBQUk7WUFDRiwyQ0FBMkM7WUFDM0MsTUFBTThDLFVBQVVDLE1BQU1DLElBQUksQ0FBQyxJQUFJLENBQUNyRCxRQUFRLENBQUNzRCxNQUFNLElBQUlDLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRXJELFVBQVUsQ0FBQ3NELElBQUksQ0FBQ3BEO1lBRS9FLElBQUksQ0FBQzhDLFNBQVM7Z0JBQ1osTUFBTSxJQUFJWCxNQUFNO1lBQ2xCO1lBRUEsSUFBSWxDO1lBQ0osSUFBSTZDLFFBQVFqRCxJQUFJLEtBQUssY0FBYztnQkFDakNJLE9BQU8sTUFBTSxJQUFJLENBQUM4QixxQkFBcUIsQ0FBQy9CO1lBQzFDLE9BQU87Z0JBQ0wsTUFBTSxJQUFJbUMsTUFBTTtZQUNsQjtZQUVBLHdEQUF3RDtZQUN4RCxPQUFPLE1BQU1XLFFBQVEvQyxXQUFXLENBQUNDLEtBQUtDO1FBQ3hDLEVBQUUsT0FBTzZCLE9BQU87WUFDZHVCLFFBQVF2QixLQUFLLENBQUMsd0JBQXdCQTtZQUN0QyxJQUFJQSxpQkFBaUJLLE9BQU87Z0JBQzFCLE1BQU0sSUFBSUEsTUFBTSxrQ0FBZ0QsT0FBZEwsTUFBTXdCLE9BQU87WUFDakU7WUFDQSxNQUFNLElBQUluQixNQUFNO1FBQ2xCO0lBQ0Y7SUExSEEsYUFBc0I7YUFGZHhDLFdBQXVDLElBQUk0RDtRQUdqRCxJQUFJLENBQUM3RCxrQkFBa0I7SUFDekI7QUF5SEY7QUFFTyxNQUFNOEQsaUJBQWlCL0QsZUFBZXVCLFdBQVcsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvc2NyYXBlci50cz8zYzAyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEl0ZW0gfSBmcm9tICdAL3R5cGVzL2l0ZW0nO1xuXG5pbnRlcmZhY2UgU2NyYXBlckNvbmZpZyB7XG4gIG5hbWU6IHN0cmluZztcbiAgdXJsUGF0dGVybjogUmVnRXhwO1xuICBleHRyYWN0RGF0YTogKHVybDogc3RyaW5nLCBkYXRhOiBhbnkpID0+IFByb21pc2U8T21pdDxJdGVtLCAnaWQnPj47XG59XG5cbmNsYXNzIFNjcmFwZXJTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFNjcmFwZXJTZXJ2aWNlO1xuICBwcml2YXRlIHNjcmFwZXJzOiBNYXA8c3RyaW5nLCBTY3JhcGVyQ29uZmlnPiA9IG5ldyBNYXAoKTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZVNjcmFwZXJzKCk7XG4gIH1cblxuICBwcml2YXRlIGluaXRpYWxpemVTY3JhcGVycygpIHtcbiAgICAvLyBDYXJkIEhvYmJ5IFNjcmFwZXJcbiAgICB0aGlzLnNjcmFwZXJzLnNldCgnY2FyZGhvYmJ5Jywge1xuICAgICAgbmFtZTogJ0NhcmQgSG9iYnknLFxuICAgICAgdXJsUGF0dGVybjogL2NhcmRob2JieVxcLmNvbVxcLmNuLyxcbiAgICAgIGV4dHJhY3REYXRhOiBhc3luYyAodXJsOiBzdHJpbmcsIGRhdGE6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBpbWFnZVVybCA9IGRhdGEuZGF0YT8uaW1hZ2VVcmwgfHwgJyc7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCaWQgPSBkYXRhLmRhdGE/LnByaWNlIHx8IDA7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBkYXRhLmRhdGE/LnRpdGxlIHx8ICdVbmtub3duIEl0ZW0nO1xuICAgICAgICBjb25zdCBzZWxsZXJVcmwgPSBkYXRhLmRhdGE/LnNlbGxlclVybCB8fCB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgaW1hZ2VVcmwsXG4gICAgICAgICAgc2VsbGVyVXJsLFxuICAgICAgICAgIGJpZDogMCxcbiAgICAgICAgICBjdXJyZW50QmlkLFxuICAgICAgICAgIG1hcmtldDogMCxcbiAgICAgICAgICBkYXRlOiBuZXcgRGF0ZShEYXRlLm5vdygpICsgMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEFkZCBtb3JlIHNjcmFwZXJzIGhlcmUgYXMgbmVlZGVkXG4gIH1cblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogU2NyYXBlclNlcnZpY2Uge1xuICAgIGlmICghU2NyYXBlclNlcnZpY2UuaW5zdGFuY2UpIHtcbiAgICAgIFNjcmFwZXJTZXJ2aWNlLmluc3RhbmNlID0gbmV3IFNjcmFwZXJTZXJ2aWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBTY3JhcGVyU2VydmljZS5pbnN0YW5jZTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hXaXRoVGltZW91dCh1cmw6IHN0cmluZywgb3B0aW9uczogUmVxdWVzdEluaXQsIHRpbWVvdXQgPSA1MDAwKTogUHJvbWlzZTxSZXNwb25zZT4ge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgaWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dCk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICAgICAgfSk7XG4gICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVDYXJkSG9iYnlTY3JhcGUodXJsOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IGNhcmRJZCA9IHVybC5zcGxpdCgnLycpLnBvcCgpO1xuICAgIGlmICghY2FyZElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVVJMIGZvcm1hdCcpO1xuICAgIH1cblxuICAgIC8vIEZpcnN0LCBuZWdvdGlhdGUgd2l0aCB0aGUgU2lnbmFsUiBodWJcbiAgICBjb25zdCBuZWdvdGlhdGVVcmwgPSBgaHR0cHM6Ly9zb2NrZXQuY2FyZGhvYmJ5LmNvbS5jbi9odWJzL25lZ290aWF0ZT9jSWQ9JHtjYXJkSWR9YDtcbiAgICBjb25zdCBuZWdvdGlhdGVSZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hXaXRoVGltZW91dChuZWdvdGlhdGVVcmwsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQWNjZXB0JzogJyovKicsXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JyxcbiAgICAgICAgJ09yaWdpbic6ICdodHRwczovL3d3dy5jYXJkaG9iYnkuY29tJyxcbiAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly93d3cuY2FyZGhvYmJ5LmNvbS8nLFxuICAgICAgICAnWC1SZXF1ZXN0ZWQtV2l0aCc6ICdYTUxIdHRwUmVxdWVzdCdcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghbmVnb3RpYXRlUmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2lnbmFsUiBuZWdvdGlhdGlvbiBmYWlsZWQ6ICR7bmVnb3RpYXRlUmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IG5lZ290aWF0ZURhdGEgPSBhd2FpdCBuZWdvdGlhdGVSZXNwb25zZS5qc29uKCk7XG5cbiAgICAvLyBHZXQgdGhlIHNwZWNpZmljIGNhcmQgZGV0YWlsc1xuICAgIGNvbnN0IGFwaVVybCA9IGBodHRwczovL2dhdGV3YXlhcGkuY2FyZGhvYmJ5LmNvbS9jYXJkL05ld015Q29tbW9kaXR5L0dldENhcmREZXRhaWw/Y2FyZElkPSR7Y2FyZElkfSZsYWc9ZW4mZGV2aWNlPVdlYiZ2ZXJzaW9uPTEmYXBwbmFtZT1DYXJkK0hvYmJ5YDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hXaXRoVGltZW91dChhcGlVcmwsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ09yaWdpbic6ICdodHRwczovL3d3dy5jYXJkaG9iYnkuY29tJyxcbiAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly93d3cuY2FyZGhvYmJ5LmNvbS8nXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSByZXF1ZXN0IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuXG4gIGFzeW5jIHNjcmFwZUl0ZW0odXJsOiBzdHJpbmcpOiBQcm9taXNlPE9taXQ8SXRlbSwgJ2lkJz4+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRmluZCB0aGUgYXBwcm9wcmlhdGUgc2NyYXBlciBmb3IgdGhlIFVSTFxuICAgICAgY29uc3Qgc2NyYXBlciA9IEFycmF5LmZyb20odGhpcy5zY3JhcGVycy52YWx1ZXMoKSkuZmluZChzID0+IHMudXJsUGF0dGVybi50ZXN0KHVybCkpO1xuICAgICAgXG4gICAgICBpZiAoIXNjcmFwZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzY3JhcGVyIGF2YWlsYWJsZSBmb3IgdGhpcyBVUkwnKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGE7XG4gICAgICBpZiAoc2NyYXBlci5uYW1lID09PSAnQ2FyZCBIb2JieScpIHtcbiAgICAgICAgZGF0YSA9IGF3YWl0IHRoaXMuaGFuZGxlQ2FyZEhvYmJ5U2NyYXBlKHVybCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHdlYnNpdGUnKTtcbiAgICAgIH1cblxuICAgICAgLy8gRXh0cmFjdCBkYXRhIHVzaW5nIHRoZSBzY3JhcGVyJ3MgZXh0cmFjdERhdGEgZnVuY3Rpb25cbiAgICAgIHJldHVybiBhd2FpdCBzY3JhcGVyLmV4dHJhY3REYXRhKHVybCwgZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNjcmFwaW5nIGl0ZW06JywgZXJyb3IpO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2NyYXBlIGl0ZW0gZGV0YWlsczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc2NyYXBlIGl0ZW0gZGV0YWlscycpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2NyYXBlclNlcnZpY2UgPSBTY3JhcGVyU2VydmljZS5nZXRJbnN0YW5jZSgpOyAiXSwibmFtZXMiOlsiU2NyYXBlclNlcnZpY2UiLCJpbml0aWFsaXplU2NyYXBlcnMiLCJzY3JhcGVycyIsInNldCIsIm5hbWUiLCJ1cmxQYXR0ZXJuIiwiZXh0cmFjdERhdGEiLCJ1cmwiLCJkYXRhIiwiaW1hZ2VVcmwiLCJjdXJyZW50QmlkIiwicHJpY2UiLCJ0aXRsZSIsInNlbGxlclVybCIsIndpbmRvdyIsImxvY2F0aW9uIiwib3JpZ2luIiwiYmlkIiwibWFya2V0IiwiZGF0ZSIsIkRhdGUiLCJub3ciLCJ0b0lTT1N0cmluZyIsImdldEluc3RhbmNlIiwiaW5zdGFuY2UiLCJmZXRjaFdpdGhUaW1lb3V0Iiwib3B0aW9ucyIsInRpbWVvdXQiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwiaWQiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJyZXNwb25zZSIsImZldGNoIiwic2lnbmFsIiwiY2xlYXJUaW1lb3V0IiwiZXJyb3IiLCJoYW5kbGVDYXJkSG9iYnlTY3JhcGUiLCJjYXJkSWQiLCJzcGxpdCIsInBvcCIsIkVycm9yIiwibmVnb3RpYXRlVXJsIiwibmVnb3RpYXRlUmVzcG9uc2UiLCJtZXRob2QiLCJoZWFkZXJzIiwib2siLCJzdGF0dXMiLCJuZWdvdGlhdGVEYXRhIiwianNvbiIsImFwaVVybCIsInNjcmFwZUl0ZW0iLCJzY3JhcGVyIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiZmluZCIsInMiLCJ0ZXN0IiwiY29uc29sZSIsIm1lc3NhZ2UiLCJNYXAiLCJzY3JhcGVyU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/scraper.ts\n"));

/***/ })

});