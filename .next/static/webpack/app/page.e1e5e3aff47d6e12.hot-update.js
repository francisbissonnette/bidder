"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/services/scraper.ts":
/*!*********************************!*\
  !*** ./src/services/scraper.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scraperService: function() { return /* binding */ scraperService; }\n/* harmony export */ });\nclass ScraperService {\n    initializeScrapers() {\n        // Card Hobby Scraper\n        this.scrapers.set(\"cardhobby\", {\n            name: \"Card Hobby\",\n            urlPattern: /cardhobby\\.com\\/#\\/carddetails\\/\\d+/,\n            rateLimit: {\n                maxRequests: 10,\n                timeWindow: 1000 * 60 // 1 minute\n            },\n            validateData: (data)=>{\n                var _data_data, _data_data1, _data_data2;\n                console.log(\"Validating Card Hobby data:\", data);\n                const isValid = (data === null || data === void 0 ? void 0 : (_data_data = data.data) === null || _data_data === void 0 ? void 0 : _data_data.imageUrl) != null && typeof (data === null || data === void 0 ? void 0 : (_data_data1 = data.data) === null || _data_data1 === void 0 ? void 0 : _data_data1.price) === \"number\" && typeof (data === null || data === void 0 ? void 0 : (_data_data2 = data.data) === null || _data_data2 === void 0 ? void 0 : _data_data2.title) === \"string\";\n                console.log(\"Validation result:\", isValid);\n                return isValid;\n            },\n            extractData: async (url, data)=>{\n                var _data_data, _data_data1, _data_data2, _data_data3;\n                console.log(\"Extracting Card Hobby data:\", data);\n                const imageUrl = ((_data_data = data.data) === null || _data_data === void 0 ? void 0 : _data_data.imageUrl) || \"\";\n                const currentBid = ((_data_data1 = data.data) === null || _data_data1 === void 0 ? void 0 : _data_data1.price) || 0;\n                const name = ((_data_data2 = data.data) === null || _data_data2 === void 0 ? void 0 : _data_data2.title) || \"Unknown Item\";\n                const sellerUrl = ((_data_data3 = data.data) === null || _data_data3 === void 0 ? void 0 : _data_data3.sellerUrl) || window.location.origin;\n                const result = {\n                    name,\n                    url,\n                    imageUrl,\n                    sellerUrl,\n                    bid: 0,\n                    currentBid,\n                    market: 0,\n                    date: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()\n                };\n                console.log(\"Extracted data:\", result);\n                return result;\n            }\n        });\n    // Add more scrapers here as needed\n    }\n    static getInstance() {\n        if (!ScraperService.instance) {\n            ScraperService.instance = new ScraperService();\n        }\n        return ScraperService.instance;\n    }\n    async waitForRateLimit(scraperName) {\n        const scraper = this.scrapers.get(scraperName);\n        if (!(scraper === null || scraper === void 0 ? void 0 : scraper.rateLimit)) return;\n        const now = Date.now();\n        const requests = this.requestCounts.get(scraperName) || [];\n        // Remove old requests outside the time window\n        const validRequests = requests.filter((time)=>now - time < scraper.rateLimit.timeWindow);\n        if (validRequests.length >= scraper.rateLimit.maxRequests) {\n            const oldestRequest = validRequests[0];\n            const waitTime = oldestRequest + scraper.rateLimit.timeWindow - now;\n            console.log(\"Rate limit reached for \".concat(scraperName, \", waiting \").concat(waitTime, \"ms\"));\n            await new Promise((resolve)=>setTimeout(resolve, waitTime));\n        }\n        // Update request count\n        this.requestCounts.set(scraperName, [\n            ...validRequests,\n            now\n        ]);\n    }\n    async fetchWithRetry(url, options) {\n        let timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5000;\n        let lastError = null;\n        for(let attempt = 0; attempt < this.MAX_RETRIES; attempt++){\n            try {\n                console.log(\"Fetch attempt \".concat(attempt + 1, \" for \").concat(url));\n                const controller = new AbortController();\n                const id = setTimeout(()=>controller.abort(), timeout);\n                const response = await fetch(url, {\n                    ...options,\n                    signal: controller.signal\n                });\n                clearTimeout(id);\n                console.log(\"Fetch successful for \".concat(url, \", status: \").concat(response.status));\n                return response;\n            } catch (error) {\n                lastError = error;\n                console.error(\"Fetch attempt \".concat(attempt + 1, \" failed:\"), error);\n                if (attempt < this.MAX_RETRIES - 1) {\n                    const delay = this.RETRY_DELAY * Math.pow(2, attempt);\n                    console.log(\"Waiting \".concat(delay, \"ms before retry\"));\n                    await new Promise((resolve)=>setTimeout(resolve, delay));\n                }\n            }\n        }\n        throw lastError || new Error(\"Failed to fetch after retries\");\n    }\n    async handleCardHobbyScrape(url) {\n        var _url_match;\n        console.log(\"Starting Card Hobby scrape for URL:\", url);\n        // Extract card ID from URL like https://www.cardhobby.com/#/carddetails/67180979\n        const cardId = (_url_match = url.match(/carddetails\\/(\\d+)/)) === null || _url_match === void 0 ? void 0 : _url_match[1];\n        if (!cardId) {\n            throw new Error(\"Invalid URL format\");\n        }\n        console.log(\"Extracted card ID:\", cardId);\n        await this.waitForRateLimit(\"cardhobby\");\n        // Get the specific card details using the direct API endpoint\n        const apiUrl = \"https://gatewayapi.cardhobby.com/card/NewMyCommodity/GetCardDetail?cardId=\".concat(cardId, \"&lag=en&device=Web&version=1&appname=Card+Hobby\");\n        console.log(\"Fetching card details from:\", apiUrl);\n        try {\n            const response = await this.fetchWithRetry(apiUrl, {\n                method: \"GET\",\n                headers: {\n                    \"Accept\": \"*/*\",\n                    \"Content-Type\": \"application/json\",\n                    \"Origin\": \"http://localhost:3000\",\n                    \"Referer\": \"http://localhost:3000/\",\n                    \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:139.0) Gecko/20100101 Firefox/139.0\",\n                    \"Accept-Language\": \"en-CA,en-US;q=0.7,en;q=0.3\",\n                    \"Accept-Encoding\": \"gzip, deflate, br, zstd\",\n                    \"Connection\": \"keep-alive\",\n                    \"Sec-Fetch-Dest\": \"empty\",\n                    \"Sec-Fetch-Mode\": \"cors\",\n                    \"Sec-Fetch-Site\": \"cross-site\"\n                },\n                mode: \"cors\",\n                credentials: \"omit\"\n            });\n            if (!response.ok) {\n                if (response.status === 404) {\n                    throw new Error(\"Card not found. Please verify the card ID is correct.\");\n                }\n                throw new Error(\"API request failed: \".concat(response.status));\n            }\n            const data = await response.json();\n            console.log(\"Card details response:\", data);\n            // Check if the response contains valid data\n            if (!(data === null || data === void 0 ? void 0 : data.data)) {\n                throw new Error(\"Invalid response format from API\");\n            }\n            return data;\n        } catch (error) {\n            console.error(\"Error fetching card details:\", error);\n            throw error;\n        }\n    }\n    isCacheValid(entry) {\n        return Date.now() - entry.timestamp < this.CACHE_DURATION;\n    }\n    async scrapeItem(url) {\n        console.log(\"Starting scrape for URL:\", url);\n        try {\n            // Check cache first\n            const cachedEntry = this.cache.get(url);\n            if (cachedEntry && this.isCacheValid(cachedEntry)) {\n                console.log(\"Returning cached data for:\", url);\n                return cachedEntry.data;\n            }\n            // Find the appropriate scraper for the URL\n            const scraper = Array.from(this.scrapers.values()).find((s)=>s.urlPattern.test(url));\n            if (!scraper) {\n                console.error(\"No scraper found for URL:\", url);\n                throw new Error(\"No scraper available for this URL\");\n            }\n            console.log(\"Found scraper:\", scraper.name);\n            let data;\n            if (scraper.name === \"Card Hobby\") {\n                data = await this.handleCardHobbyScrape(url);\n            } else {\n                console.error(\"Unsupported website:\", url);\n                throw new Error(\"Unsupported website\");\n            }\n            // Validate the data\n            if (!scraper.validateData(data)) {\n                console.error(\"Invalid data received:\", data);\n                throw new Error(\"Invalid data received from scraper\");\n            }\n            // Extract data using the scraper's extractData function\n            const extractedData = await scraper.extractData(url, data);\n            // Cache the result\n            this.cache.set(url, {\n                data: extractedData,\n                timestamp: Date.now()\n            });\n            console.log(\"Successfully scraped and cached data for:\", url);\n            return extractedData;\n        } catch (error) {\n            console.error(\"Error scraping item:\", error);\n            if (error instanceof Error) {\n                throw new Error(\"Failed to scrape item details: \".concat(error.message));\n            }\n            throw new Error(\"Failed to scrape item details\");\n        }\n    }\n    // Method to clear cache for a specific URL or all URLs\n    clearCache(url) {\n        if (url) {\n            this.cache.delete(url);\n            console.log(\"Cleared cache for URL:\", url);\n        } else {\n            this.cache.clear();\n            console.log(\"Cleared all cache\");\n        }\n    }\n    constructor(){\n        this.scrapers = new Map();\n        this.cache = new Map();\n        this.requestCounts = new Map();\n        this.CACHE_DURATION = 1000 * 60 * 5 // 5 minutes\n        ;\n        this.MAX_RETRIES = 3;\n        this.RETRY_DELAY = 1000 // 1 second\n        ;\n        this.initializeScrapers();\n    }\n}\nconst scraperService = ScraperService.getInstance();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9zY3JhcGVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFrQkEsTUFBTUE7SUFhSUMscUJBQXFCO1FBQzNCLHFCQUFxQjtRQUNyQixJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDLGFBQWE7WUFDN0JDLE1BQU07WUFDTkMsWUFBWTtZQUNaQyxXQUFXO2dCQUNUQyxhQUFhO2dCQUNiQyxZQUFZLE9BQU8sR0FBRyxXQUFXO1lBQ25DO1lBQ0FDLGNBQWMsQ0FBQ0M7b0JBRUdBLFlBQ0ZBLGFBQ0FBO2dCQUhkQyxRQUFRQyxHQUFHLENBQUMsK0JBQStCRjtnQkFDM0MsTUFBTUcsVUFBVUgsQ0FBQUEsaUJBQUFBLDRCQUFBQSxhQUFBQSxLQUFNQSxJQUFJLGNBQVZBLGlDQUFBQSxXQUFZSSxRQUFRLEtBQUksUUFDakMsUUFBT0osaUJBQUFBLDRCQUFBQSxjQUFBQSxLQUFNQSxJQUFJLGNBQVZBLGtDQUFBQSxZQUFZSyxLQUFLLE1BQUssWUFDN0IsUUFBT0wsaUJBQUFBLDRCQUFBQSxjQUFBQSxLQUFNQSxJQUFJLGNBQVZBLGtDQUFBQSxZQUFZTSxLQUFLLE1BQUs7Z0JBQ3BDTCxRQUFRQyxHQUFHLENBQUMsc0JBQXNCQztnQkFDbEMsT0FBT0E7WUFDVDtZQUNBSSxhQUFhLE9BQU9DLEtBQWFSO29CQUVkQSxZQUNFQSxhQUNOQSxhQUNLQTtnQkFKbEJDLFFBQVFDLEdBQUcsQ0FBQywrQkFBK0JGO2dCQUMzQyxNQUFNSSxXQUFXSixFQUFBQSxhQUFBQSxLQUFLQSxJQUFJLGNBQVRBLGlDQUFBQSxXQUFXSSxRQUFRLEtBQUk7Z0JBQ3hDLE1BQU1LLGFBQWFULEVBQUFBLGNBQUFBLEtBQUtBLElBQUksY0FBVEEsa0NBQUFBLFlBQVdLLEtBQUssS0FBSTtnQkFDdkMsTUFBTVgsT0FBT00sRUFBQUEsY0FBQUEsS0FBS0EsSUFBSSxjQUFUQSxrQ0FBQUEsWUFBV00sS0FBSyxLQUFJO2dCQUNqQyxNQUFNSSxZQUFZ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YyxLQUFNLFdBQVc7O1FBRzlDLElBQUksQ0FBQ2hFLGtCQUFrQjtJQUN6QjtBQW9PRjtBQUVPLE1BQU1pRyxpQkFBaUJsRyxlQUFlK0IsV0FBVyxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy9zY3JhcGVyLnRzPzNjMDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSXRlbSB9IGZyb20gJ0AvdHlwZXMvaXRlbSc7XG5cbmludGVyZmFjZSBTY3JhcGVyQ29uZmlnIHtcbiAgbmFtZTogc3RyaW5nO1xuICB1cmxQYXR0ZXJuOiBSZWdFeHA7XG4gIGV4dHJhY3REYXRhOiAodXJsOiBzdHJpbmcsIGRhdGE6IGFueSkgPT4gUHJvbWlzZTxPbWl0PEl0ZW0sICdpZCc+PjtcbiAgdmFsaWRhdGVEYXRhOiAoZGF0YTogYW55KSA9PiBib29sZWFuO1xuICByYXRlTGltaXQ/OiB7XG4gICAgbWF4UmVxdWVzdHM6IG51bWJlcjtcbiAgICB0aW1lV2luZG93OiBudW1iZXI7IC8vIGluIG1pbGxpc2Vjb25kc1xuICB9O1xufVxuXG5pbnRlcmZhY2UgQ2FjaGVFbnRyeSB7XG4gIGRhdGE6IE9taXQ8SXRlbSwgJ2lkJz47XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5jbGFzcyBTY3JhcGVyU2VydmljZSB7XG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBTY3JhcGVyU2VydmljZTtcbiAgcHJpdmF0ZSBzY3JhcGVyczogTWFwPHN0cmluZywgU2NyYXBlckNvbmZpZz4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgY2FjaGU6IE1hcDxzdHJpbmcsIENhY2hlRW50cnk+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHJlcXVlc3RDb3VudHM6IE1hcDxzdHJpbmcsIG51bWJlcltdPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSByZWFkb25seSBDQUNIRV9EVVJBVElPTiA9IDEwMDAgKiA2MCAqIDU7IC8vIDUgbWludXRlc1xuICBwcml2YXRlIHJlYWRvbmx5IE1BWF9SRVRSSUVTID0gMztcbiAgcHJpdmF0ZSByZWFkb25seSBSRVRSWV9ERUxBWSA9IDEwMDA7IC8vIDEgc2Vjb25kXG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmluaXRpYWxpemVTY3JhcGVycygpO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplU2NyYXBlcnMoKSB7XG4gICAgLy8gQ2FyZCBIb2JieSBTY3JhcGVyXG4gICAgdGhpcy5zY3JhcGVycy5zZXQoJ2NhcmRob2JieScsIHtcbiAgICAgIG5hbWU6ICdDYXJkIEhvYmJ5JyxcbiAgICAgIHVybFBhdHRlcm46IC9jYXJkaG9iYnlcXC5jb21cXC8jXFwvY2FyZGRldGFpbHNcXC9cXGQrLyxcbiAgICAgIHJhdGVMaW1pdDoge1xuICAgICAgICBtYXhSZXF1ZXN0czogMTAsXG4gICAgICAgIHRpbWVXaW5kb3c6IDEwMDAgKiA2MCAvLyAxIG1pbnV0ZVxuICAgICAgfSxcbiAgICAgIHZhbGlkYXRlRGF0YTogKGRhdGE6IGFueSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnVmFsaWRhdGluZyBDYXJkIEhvYmJ5IGRhdGE6JywgZGF0YSk7XG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSBkYXRhPy5kYXRhPy5pbWFnZVVybCAhPSBudWxsICYmIFxuICAgICAgICAgICAgICAgdHlwZW9mIGRhdGE/LmRhdGE/LnByaWNlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgdHlwZW9mIGRhdGE/LmRhdGE/LnRpdGxlID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc29sZS5sb2coJ1ZhbGlkYXRpb24gcmVzdWx0OicsIGlzVmFsaWQpO1xuICAgICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICAgIH0sXG4gICAgICBleHRyYWN0RGF0YTogYXN5bmMgKHVybDogc3RyaW5nLCBkYXRhOiBhbnkpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ0V4dHJhY3RpbmcgQ2FyZCBIb2JieSBkYXRhOicsIGRhdGEpO1xuICAgICAgICBjb25zdCBpbWFnZVVybCA9IGRhdGEuZGF0YT8uaW1hZ2VVcmwgfHwgJyc7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCaWQgPSBkYXRhLmRhdGE/LnByaWNlIHx8IDA7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBkYXRhLmRhdGE/LnRpdGxlIHx8ICdVbmtub3duIEl0ZW0nO1xuICAgICAgICBjb25zdCBzZWxsZXJVcmwgPSBkYXRhLmRhdGE/LnNlbGxlclVybCB8fCB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICBpbWFnZVVybCxcbiAgICAgICAgICBzZWxsZXJVcmwsXG4gICAgICAgICAgYmlkOiAwLFxuICAgICAgICAgIGN1cnJlbnRCaWQsXG4gICAgICAgICAgbWFya2V0OiAwLFxuICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKERhdGUubm93KCkgKyAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmxvZygnRXh0cmFjdGVkIGRhdGE6JywgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEFkZCBtb3JlIHNjcmFwZXJzIGhlcmUgYXMgbmVlZGVkXG4gIH1cblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogU2NyYXBlclNlcnZpY2Uge1xuICAgIGlmICghU2NyYXBlclNlcnZpY2UuaW5zdGFuY2UpIHtcbiAgICAgIFNjcmFwZXJTZXJ2aWNlLmluc3RhbmNlID0gbmV3IFNjcmFwZXJTZXJ2aWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBTY3JhcGVyU2VydmljZS5pbnN0YW5jZTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgd2FpdEZvclJhdGVMaW1pdChzY3JhcGVyTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc2NyYXBlciA9IHRoaXMuc2NyYXBlcnMuZ2V0KHNjcmFwZXJOYW1lKTtcbiAgICBpZiAoIXNjcmFwZXI/LnJhdGVMaW1pdCkgcmV0dXJuO1xuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCByZXF1ZXN0cyA9IHRoaXMucmVxdWVzdENvdW50cy5nZXQoc2NyYXBlck5hbWUpIHx8IFtdO1xuICAgIFxuICAgIC8vIFJlbW92ZSBvbGQgcmVxdWVzdHMgb3V0c2lkZSB0aGUgdGltZSB3aW5kb3dcbiAgICBjb25zdCB2YWxpZFJlcXVlc3RzID0gcmVxdWVzdHMuZmlsdGVyKHRpbWUgPT4gbm93IC0gdGltZSA8IHNjcmFwZXIucmF0ZUxpbWl0IS50aW1lV2luZG93KTtcbiAgICBcbiAgICBpZiAodmFsaWRSZXF1ZXN0cy5sZW5ndGggPj0gc2NyYXBlci5yYXRlTGltaXQhLm1heFJlcXVlc3RzKSB7XG4gICAgICBjb25zdCBvbGRlc3RSZXF1ZXN0ID0gdmFsaWRSZXF1ZXN0c1swXTtcbiAgICAgIGNvbnN0IHdhaXRUaW1lID0gb2xkZXN0UmVxdWVzdCArIHNjcmFwZXIucmF0ZUxpbWl0IS50aW1lV2luZG93IC0gbm93O1xuICAgICAgY29uc29sZS5sb2coYFJhdGUgbGltaXQgcmVhY2hlZCBmb3IgJHtzY3JhcGVyTmFtZX0sIHdhaXRpbmcgJHt3YWl0VGltZX1tc2ApO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHdhaXRUaW1lKSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHJlcXVlc3QgY291bnRcbiAgICB0aGlzLnJlcXVlc3RDb3VudHMuc2V0KHNjcmFwZXJOYW1lLCBbLi4udmFsaWRSZXF1ZXN0cywgbm93XSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZldGNoV2l0aFJldHJ5KHVybDogc3RyaW5nLCBvcHRpb25zOiBSZXF1ZXN0SW5pdCwgdGltZW91dCA9IDUwMDApOiBQcm9taXNlPFJlc3BvbnNlPiB7XG4gICAgbGV0IGxhc3RFcnJvcjogRXJyb3IgfCBudWxsID0gbnVsbDtcbiAgICBcbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IHRoaXMuTUFYX1JFVFJJRVM7IGF0dGVtcHQrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYEZldGNoIGF0dGVtcHQgJHthdHRlbXB0ICsgMX0gZm9yICR7dXJsfWApO1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCBpZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KTtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBGZXRjaCBzdWNjZXNzZnVsIGZvciAke3VybH0sIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxhc3RFcnJvciA9IGVycm9yIGFzIEVycm9yO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBGZXRjaCBhdHRlbXB0ICR7YXR0ZW1wdCArIDF9IGZhaWxlZDpgLCBlcnJvcik7XG4gICAgICAgIGlmIChhdHRlbXB0IDwgdGhpcy5NQVhfUkVUUklFUyAtIDEpIHtcbiAgICAgICAgICBjb25zdCBkZWxheSA9IHRoaXMuUkVUUllfREVMQVkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgV2FpdGluZyAke2RlbGF5fW1zIGJlZm9yZSByZXRyeWApO1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbGFzdEVycm9yIHx8IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIGFmdGVyIHJldHJpZXMnKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlQ2FyZEhvYmJ5U2NyYXBlKHVybDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgQ2FyZCBIb2JieSBzY3JhcGUgZm9yIFVSTDonLCB1cmwpO1xuICAgIC8vIEV4dHJhY3QgY2FyZCBJRCBmcm9tIFVSTCBsaWtlIGh0dHBzOi8vd3d3LmNhcmRob2JieS5jb20vIy9jYXJkZGV0YWlscy82NzE4MDk3OVxuICAgIGNvbnN0IGNhcmRJZCA9IHVybC5tYXRjaCgvY2FyZGRldGFpbHNcXC8oXFxkKykvKT8uWzFdO1xuICAgIGlmICghY2FyZElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVVJMIGZvcm1hdCcpO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZygnRXh0cmFjdGVkIGNhcmQgSUQ6JywgY2FyZElkKTtcblxuICAgIGF3YWl0IHRoaXMud2FpdEZvclJhdGVMaW1pdCgnY2FyZGhvYmJ5Jyk7XG5cbiAgICAvLyBHZXQgdGhlIHNwZWNpZmljIGNhcmQgZGV0YWlscyB1c2luZyB0aGUgZGlyZWN0IEFQSSBlbmRwb2ludFxuICAgIGNvbnN0IGFwaVVybCA9IGBodHRwczovL2dhdGV3YXlhcGkuY2FyZGhvYmJ5LmNvbS9jYXJkL05ld015Q29tbW9kaXR5L0dldENhcmREZXRhaWw/Y2FyZElkPSR7Y2FyZElkfSZsYWc9ZW4mZGV2aWNlPVdlYiZ2ZXJzaW9uPTEmYXBwbmFtZT1DYXJkK0hvYmJ5YDtcbiAgICBjb25zb2xlLmxvZygnRmV0Y2hpbmcgY2FyZCBkZXRhaWxzIGZyb206JywgYXBpVXJsKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoV2l0aFJldHJ5KGFwaVVybCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0FjY2VwdCc6ICcqLyonLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ09yaWdpbic6ICdodHRwOi8vbG9jYWxob3N0OjMwMDAnLFxuICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC8nLFxuICAgICAgICAgICdVc2VyLUFnZW50JzogJ01vemlsbGEvNS4wIChNYWNpbnRvc2g7IEludGVsIE1hYyBPUyBYIDEwLjE1OyBydjoxMzkuMCkgR2Vja28vMjAxMDAxMDEgRmlyZWZveC8xMzkuMCcsXG4gICAgICAgICAgJ0FjY2VwdC1MYW5ndWFnZSc6ICdlbi1DQSxlbi1VUztxPTAuNyxlbjtxPTAuMycsXG4gICAgICAgICAgJ0FjY2VwdC1FbmNvZGluZyc6ICdnemlwLCBkZWZsYXRlLCBiciwgenN0ZCcsXG4gICAgICAgICAgJ0Nvbm5lY3Rpb24nOiAna2VlcC1hbGl2ZScsXG4gICAgICAgICAgJ1NlYy1GZXRjaC1EZXN0JzogJ2VtcHR5JyxcbiAgICAgICAgICAnU2VjLUZldGNoLU1vZGUnOiAnY29ycycsXG4gICAgICAgICAgJ1NlYy1GZXRjaC1TaXRlJzogJ2Nyb3NzLXNpdGUnXG4gICAgICAgIH0sXG4gICAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgICAgY3JlZGVudGlhbHM6ICdvbWl0J1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYXJkIG5vdCBmb3VuZC4gUGxlYXNlIHZlcmlmeSB0aGUgY2FyZCBJRCBpcyBjb3JyZWN0LicpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIHJlcXVlc3QgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKCdDYXJkIGRldGFpbHMgcmVzcG9uc2U6JywgZGF0YSk7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSByZXNwb25zZSBjb250YWlucyB2YWxpZCBkYXRhXG4gICAgICBpZiAoIWRhdGE/LmRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdCBmcm9tIEFQSScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY2FyZCBkZXRhaWxzOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaXNDYWNoZVZhbGlkKGVudHJ5OiBDYWNoZUVudHJ5KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIERhdGUubm93KCkgLSBlbnRyeS50aW1lc3RhbXAgPCB0aGlzLkNBQ0hFX0RVUkFUSU9OO1xuICB9XG5cbiAgYXN5bmMgc2NyYXBlSXRlbSh1cmw6IHN0cmluZyk6IFByb21pc2U8T21pdDxJdGVtLCAnaWQnPj4ge1xuICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBzY3JhcGUgZm9yIFVSTDonLCB1cmwpO1xuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBjYWNoZSBmaXJzdFxuICAgICAgY29uc3QgY2FjaGVkRW50cnkgPSB0aGlzLmNhY2hlLmdldCh1cmwpO1xuICAgICAgaWYgKGNhY2hlZEVudHJ5ICYmIHRoaXMuaXNDYWNoZVZhbGlkKGNhY2hlZEVudHJ5KSkge1xuICAgICAgICBjb25zb2xlLmxvZygnUmV0dXJuaW5nIGNhY2hlZCBkYXRhIGZvcjonLCB1cmwpO1xuICAgICAgICByZXR1cm4gY2FjaGVkRW50cnkuZGF0YTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCB0aGUgYXBwcm9wcmlhdGUgc2NyYXBlciBmb3IgdGhlIFVSTFxuICAgICAgY29uc3Qgc2NyYXBlciA9IEFycmF5LmZyb20odGhpcy5zY3JhcGVycy52YWx1ZXMoKSkuZmluZChzID0+IHMudXJsUGF0dGVybi50ZXN0KHVybCkpO1xuICAgICAgXG4gICAgICBpZiAoIXNjcmFwZXIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTm8gc2NyYXBlciBmb3VuZCBmb3IgVVJMOicsIHVybCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2NyYXBlciBhdmFpbGFibGUgZm9yIHRoaXMgVVJMJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBzY3JhcGVyOicsIHNjcmFwZXIubmFtZSk7XG5cbiAgICAgIGxldCBkYXRhO1xuICAgICAgaWYgKHNjcmFwZXIubmFtZSA9PT0gJ0NhcmQgSG9iYnknKSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCB0aGlzLmhhbmRsZUNhcmRIb2JieVNjcmFwZSh1cmwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVW5zdXBwb3J0ZWQgd2Vic2l0ZTonLCB1cmwpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHdlYnNpdGUnKTtcbiAgICAgIH1cblxuICAgICAgLy8gVmFsaWRhdGUgdGhlIGRhdGFcbiAgICAgIGlmICghc2NyYXBlci52YWxpZGF0ZURhdGEoZGF0YSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBkYXRhIHJlY2VpdmVkOicsIGRhdGEpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YSByZWNlaXZlZCBmcm9tIHNjcmFwZXInKTtcbiAgICAgIH1cblxuICAgICAgLy8gRXh0cmFjdCBkYXRhIHVzaW5nIHRoZSBzY3JhcGVyJ3MgZXh0cmFjdERhdGEgZnVuY3Rpb25cbiAgICAgIGNvbnN0IGV4dHJhY3RlZERhdGEgPSBhd2FpdCBzY3JhcGVyLmV4dHJhY3REYXRhKHVybCwgZGF0YSk7XG5cbiAgICAgIC8vIENhY2hlIHRoZSByZXN1bHRcbiAgICAgIHRoaXMuY2FjaGUuc2V0KHVybCwge1xuICAgICAgICBkYXRhOiBleHRyYWN0ZWREYXRhLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IHNjcmFwZWQgYW5kIGNhY2hlZCBkYXRhIGZvcjonLCB1cmwpO1xuICAgICAgcmV0dXJuIGV4dHJhY3RlZERhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNjcmFwaW5nIGl0ZW06JywgZXJyb3IpO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2NyYXBlIGl0ZW0gZGV0YWlsczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc2NyYXBlIGl0ZW0gZGV0YWlscycpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1ldGhvZCB0byBjbGVhciBjYWNoZSBmb3IgYSBzcGVjaWZpYyBVUkwgb3IgYWxsIFVSTHNcbiAgY2xlYXJDYWNoZSh1cmw/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodXJsKSB7XG4gICAgICB0aGlzLmNhY2hlLmRlbGV0ZSh1cmwpO1xuICAgICAgY29uc29sZS5sb2coJ0NsZWFyZWQgY2FjaGUgZm9yIFVSTDonLCB1cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhY2hlLmNsZWFyKCk7XG4gICAgICBjb25zb2xlLmxvZygnQ2xlYXJlZCBhbGwgY2FjaGUnKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNjcmFwZXJTZXJ2aWNlID0gU2NyYXBlclNlcnZpY2UuZ2V0SW5zdGFuY2UoKTsgIl0sIm5hbWVzIjpbIlNjcmFwZXJTZXJ2aWNlIiwiaW5pdGlhbGl6ZVNjcmFwZXJzIiwic2NyYXBlcnMiLCJzZXQiLCJuYW1lIiwidXJsUGF0dGVybiIsInJhdGVMaW1pdCIsIm1heFJlcXVlc3RzIiwidGltZVdpbmRvdyIsInZhbGlkYXRlRGF0YSIsImRhdGEiLCJjb25zb2xlIiwibG9nIiwiaXNWYWxpZCIsImltYWdlVXJsIiwicHJpY2UiLCJ0aXRsZSIsImV4dHJhY3REYXRhIiwidXJsIiwiY3VycmVudEJpZCIsInNlbGxlclVybCIsIndpbmRvdyIsImxvY2F0aW9uIiwib3JpZ2luIiwicmVzdWx0IiwiYmlkIiwibWFya2V0IiwiZGF0ZSIsIkRhdGUiLCJub3ciLCJ0b0lTT1N0cmluZyIsImdldEluc3RhbmNlIiwiaW5zdGFuY2UiLCJ3YWl0Rm9yUmF0ZUxpbWl0Iiwic2NyYXBlck5hbWUiLCJzY3JhcGVyIiwiZ2V0IiwicmVxdWVzdHMiLCJyZXF1ZXN0Q291bnRzIiwidmFsaWRSZXF1ZXN0cyIsImZpbHRlciIsInRpbWUiLCJsZW5ndGgiLCJvbGRlc3RSZXF1ZXN0Iiwid2FpdFRpbWUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJmZXRjaFdpdGhSZXRyeSIsIm9wdGlvbnMiLCJ0aW1lb3V0IiwibGFzdEVycm9yIiwiYXR0ZW1wdCIsIk1BWF9SRVRSSUVTIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsImlkIiwiYWJvcnQiLCJyZXNwb25zZSIsImZldGNoIiwic2lnbmFsIiwiY2xlYXJUaW1lb3V0Iiwic3RhdHVzIiwiZXJyb3IiLCJkZWxheSIsIlJFVFJZX0RFTEFZIiwiTWF0aCIsInBvdyIsIkVycm9yIiwiaGFuZGxlQ2FyZEhvYmJ5U2NyYXBlIiwiY2FyZElkIiwibWF0Y2giLCJhcGlVcmwiLCJtZXRob2QiLCJoZWFkZXJzIiwibW9kZSIsImNyZWRlbnRpYWxzIiwib2siLCJqc29uIiwiaXNDYWNoZVZhbGlkIiwiZW50cnkiLCJ0aW1lc3RhbXAiLCJDQUNIRV9EVVJBVElPTiIsInNjcmFwZUl0ZW0iLCJjYWNoZWRFbnRyeSIsImNhY2hlIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiZmluZCIsInMiLCJ0ZXN0IiwiZXh0cmFjdGVkRGF0YSIsIm1lc3NhZ2UiLCJjbGVhckNhY2hlIiwiZGVsZXRlIiwiY2xlYXIiLCJNYXAiLCJzY3JhcGVyU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/scraper.ts\n"));

/***/ })

});